using System;
using UnityEngine;
using System.Runtime.InteropServices;
using System.Text;
using ImGuiNET;

namespace ImPlotNET
{
    public static unsafe partial class ImPlot
    {
        public static ImPlotColormap AddColormap(string name, ref Vector4 cols, int size)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            byte qual = 1;
            fixed (Vector4* native_cols = &cols)
            {
                ImPlotColormap ret = ImPlotNative.ImPlot_AddColormap_Vec4Ptr(native_name, native_cols, size, qual);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_name);
                }
                return ret;
            }
        }
        public static ImPlotColormap AddColormap(string name, ref Vector4 cols, int size, bool qual)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            byte native_qual = qual ? (byte)1 : (byte)0;
            fixed (Vector4* native_cols = &cols)
            {
                ImPlotColormap ret = ImPlotNative.ImPlot_AddColormap_Vec4Ptr(native_name, native_cols, size, native_qual);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_name);
                }
                return ret;
            }
        }
        public static ImPlotColormap AddColormap(string name, ref uint cols, int size)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            byte qual = 1;
            fixed (uint* native_cols = &cols)
            {
                ImPlotColormap ret = ImPlotNative.ImPlot_AddColormap_U32Ptr(native_name, native_cols, size, qual);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_name);
                }
                return ret;
            }
        }
        public static ImPlotColormap AddColormap(string name, ref uint cols, int size, bool qual)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            byte native_qual = qual ? (byte)1 : (byte)0;
            fixed (uint* native_cols = &cols)
            {
                ImPlotColormap ret = ImPlotNative.ImPlot_AddColormap_U32Ptr(native_name, native_cols, size, native_qual);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_name);
                }
                return ret;
            }
        }
        public static void Annotate(double x, double y, Vector2 pix_offset, string fmt)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_Annotate_Str(x, y, pix_offset, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static void Annotate(double x, double y, Vector2 pix_offset, Vector4 color, string fmt)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_Annotate_Vec4(x, y, pix_offset, color, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static void AnnotateClamped(double x, double y, Vector2 pix_offset, string fmt)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_AnnotateClamped_Str(x, y, pix_offset, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static void AnnotateClamped(double x, double y, Vector2 pix_offset, Vector4 color, string fmt)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_AnnotateClamped_Vec4(x, y, pix_offset, color, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static bool BeginDragDropSource()
        {
            ImGuiKeyModFlags key_mods = ImGuiKeyModFlags.Ctrl;
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSource(key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSource(ImGuiKeyModFlags key_mods)
        {
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSource(key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSource(ImGuiKeyModFlags key_mods, ImGuiDragDropFlags flags)
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropSource(key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSourceItem(string label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceItem(native_label_id, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool BeginDragDropSourceItem(string label_id, ImGuiDragDropFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceItem(native_label_id, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool BeginDragDropSourceX()
        {
            ImGuiKeyModFlags key_mods = ImGuiKeyModFlags.Ctrl;
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceX(key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSourceX(ImGuiKeyModFlags key_mods)
        {
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceX(key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSourceX(ImGuiKeyModFlags key_mods, ImGuiDragDropFlags flags)
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceX(key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSourceY()
        {
            ImPlotYAxis axis = ImPlotYAxis._1;
            ImGuiKeyModFlags key_mods = ImGuiKeyModFlags.Ctrl;
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceY(axis, key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSourceY(ImPlotYAxis axis)
        {
            ImGuiKeyModFlags key_mods = ImGuiKeyModFlags.Ctrl;
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceY(axis, key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSourceY(ImPlotYAxis axis, ImGuiKeyModFlags key_mods)
        {
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceY(axis, key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSourceY(ImPlotYAxis axis, ImGuiKeyModFlags key_mods, ImGuiDragDropFlags flags)
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceY(axis, key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropTarget()
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropTarget();
            return ret != 0;
        }
        public static bool BeginDragDropTargetLegend()
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropTargetLegend();
            return ret != 0;
        }
        public static bool BeginDragDropTargetX()
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropTargetX();
            return ret != 0;
        }
        public static bool BeginDragDropTargetY()
        {
            ImPlotYAxis axis = ImPlotYAxis._1;
            byte ret = ImPlotNative.ImPlot_BeginDragDropTargetY(axis);
            return ret != 0;
        }
        public static bool BeginDragDropTargetY(ImPlotYAxis axis)
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropTargetY(axis);
            return ret != 0;
        }
        public static bool BeginLegendPopup(string label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImGuiMouseButton mouse_button = (ImGuiMouseButton)1;
            byte ret = ImPlotNative.ImPlot_BeginLegendPopup(native_label_id, mouse_button);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool BeginLegendPopup(string label_id, ImGuiMouseButton mouse_button)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte ret = ImPlotNative.ImPlot_BeginLegendPopup(native_label_id, mouse_button);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label = null;
            byte* native_y_label = null;
            Vector2 size = new Vector2(-1, 0);
            ImPlotFlags flags = ImPlotFlags.None;
            ImPlotAxisFlags x_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y2_flags = ImPlotAxisFlags.NoGridLines;
            ImPlotAxisFlags y3_flags = ImPlotAxisFlags.NoGridLines;
            byte* native_y2_label = null;
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label = null;
            Vector2 size = new Vector2(-1, 0);
            ImPlotFlags flags = ImPlotFlags.None;
            ImPlotAxisFlags x_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y2_flags = ImPlotAxisFlags.NoGridLines;
            ImPlotAxisFlags y3_flags = ImPlotAxisFlags.NoGridLines;
            byte* native_y2_label = null;
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label, string y_label)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            Vector2 size = new Vector2(-1, 0);
            ImPlotFlags flags = ImPlotFlags.None;
            ImPlotAxisFlags x_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y2_flags = ImPlotAxisFlags.NoGridLines;
            ImPlotAxisFlags y3_flags = ImPlotAxisFlags.NoGridLines;
            byte* native_y2_label = null;
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label, string y_label, Vector2 size)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            ImPlotFlags flags = ImPlotFlags.None;
            ImPlotAxisFlags x_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y2_flags = ImPlotAxisFlags.NoGridLines;
            ImPlotAxisFlags y3_flags = ImPlotAxisFlags.NoGridLines;
            byte* native_y2_label = null;
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label, string y_label, Vector2 size, ImPlotFlags flags)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            ImPlotAxisFlags x_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y2_flags = ImPlotAxisFlags.NoGridLines;
            ImPlotAxisFlags y3_flags = ImPlotAxisFlags.NoGridLines;
            byte* native_y2_label = null;
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label, string y_label, Vector2 size, ImPlotFlags flags, ImPlotAxisFlags x_flags)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            ImPlotAxisFlags y_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y2_flags = ImPlotAxisFlags.NoGridLines;
            ImPlotAxisFlags y3_flags = ImPlotAxisFlags.NoGridLines;
            byte* native_y2_label = null;
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label, string y_label, Vector2 size, ImPlotFlags flags, ImPlotAxisFlags x_flags, ImPlotAxisFlags y_flags)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            ImPlotAxisFlags y2_flags = ImPlotAxisFlags.NoGridLines;
            ImPlotAxisFlags y3_flags = ImPlotAxisFlags.NoGridLines;
            byte* native_y2_label = null;
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label, string y_label, Vector2 size, ImPlotFlags flags, ImPlotAxisFlags x_flags, ImPlotAxisFlags y_flags, ImPlotAxisFlags y2_flags)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            ImPlotAxisFlags y3_flags = ImPlotAxisFlags.NoGridLines;
            byte* native_y2_label = null;
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label, string y_label, Vector2 size, ImPlotFlags flags, ImPlotAxisFlags x_flags, ImPlotAxisFlags y_flags, ImPlotAxisFlags y2_flags, ImPlotAxisFlags y3_flags)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            byte* native_y2_label = null;
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label, string y_label, Vector2 size, ImPlotFlags flags, ImPlotAxisFlags x_flags, ImPlotAxisFlags y_flags, ImPlotAxisFlags y2_flags, ImPlotAxisFlags y3_flags, string y2_label)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            byte* native_y2_label;
            int y2_label_byteCount = 0;
            if (y2_label != null)
            {
                y2_label_byteCount = Encoding.UTF8.GetByteCount(y2_label);
                if (y2_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y2_label = Util.Allocate(y2_label_byteCount + 1);
                }
                else
                {
                    byte* native_y2_label_stackBytes = stackalloc byte[y2_label_byteCount + 1];
                    native_y2_label = native_y2_label_stackBytes;
                }
                int native_y2_label_offset = Util.GetUtf8(y2_label, native_y2_label, y2_label_byteCount);
                native_y2_label[native_y2_label_offset] = 0;
            }
            else { native_y2_label = null; }
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
            if (y2_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y2_label);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label, string y_label, Vector2 size, ImPlotFlags flags, ImPlotAxisFlags x_flags, ImPlotAxisFlags y_flags, ImPlotAxisFlags y2_flags, ImPlotAxisFlags y3_flags, string y2_label, string y3_label)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            byte* native_y2_label;
            int y2_label_byteCount = 0;
            if (y2_label != null)
            {
                y2_label_byteCount = Encoding.UTF8.GetByteCount(y2_label);
                if (y2_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y2_label = Util.Allocate(y2_label_byteCount + 1);
                }
                else
                {
                    byte* native_y2_label_stackBytes = stackalloc byte[y2_label_byteCount + 1];
                    native_y2_label = native_y2_label_stackBytes;
                }
                int native_y2_label_offset = Util.GetUtf8(y2_label, native_y2_label, y2_label_byteCount);
                native_y2_label[native_y2_label_offset] = 0;
            }
            else { native_y2_label = null; }
            byte* native_y3_label;
            int y3_label_byteCount = 0;
            if (y3_label != null)
            {
                y3_label_byteCount = Encoding.UTF8.GetByteCount(y3_label);
                if (y3_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y3_label = Util.Allocate(y3_label_byteCount + 1);
                }
                else
                {
                    byte* native_y3_label_stackBytes = stackalloc byte[y3_label_byteCount + 1];
                    native_y3_label = native_y3_label_stackBytes;
                }
                int native_y3_label_offset = Util.GetUtf8(y3_label, native_y3_label, y3_label_byteCount);
                native_y3_label[native_y3_label_offset] = 0;
            }
            else { native_y3_label = null; }
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
            if (y2_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y2_label);
            }
            if (y3_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y3_label);
            }
            return ret != 0;
        }
        public static void BustColorCache()
        {
            byte* native_plot_title_id = null;
            ImPlotNative.ImPlot_BustColorCache(native_plot_title_id);
        }
        public static void BustColorCache(string plot_title_id)
        {
            byte* native_plot_title_id;
            int plot_title_id_byteCount = 0;
            if (plot_title_id != null)
            {
                plot_title_id_byteCount = Encoding.UTF8.GetByteCount(plot_title_id);
                if (plot_title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_plot_title_id = Util.Allocate(plot_title_id_byteCount + 1);
                }
                else
                {
                    byte* native_plot_title_id_stackBytes = stackalloc byte[plot_title_id_byteCount + 1];
                    native_plot_title_id = native_plot_title_id_stackBytes;
                }
                int native_plot_title_id_offset = Util.GetUtf8(plot_title_id, native_plot_title_id, plot_title_id_byteCount);
                native_plot_title_id[native_plot_title_id_offset] = 0;
            }
            else { native_plot_title_id = null; }
            ImPlotNative.ImPlot_BustColorCache(native_plot_title_id);
            if (plot_title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_plot_title_id);
            }
        }
        public static bool ColormapButton(string label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            Vector2 size = new Vector2();
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            byte ret = ImPlotNative.ImPlot_ColormapButton(native_label, size, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
        public static bool ColormapButton(string label, Vector2 size)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            byte ret = ImPlotNative.ImPlot_ColormapButton(native_label, size, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
        public static bool ColormapButton(string label, Vector2 size, ImPlotColormap cmap)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte ret = ImPlotNative.ImPlot_ColormapButton(native_label, size, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
        public static void ColormapIcon(ImPlotColormap cmap)
        {
            ImPlotNative.ImPlot_ColormapIcon(cmap);
        }
        public static void ColormapScale(string label, double scale_min, double scale_max)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            Vector2 size = new Vector2();
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            byte* native_fmt;
            int fmt_byteCount = 0;
                fmt_byteCount = Encoding.UTF8.GetByteCount("%g");
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8("%g", native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            ImPlotNative.ImPlot_ColormapScale(native_label, scale_min, scale_max, size, cmap, native_fmt);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static void ColormapScale(string label, double scale_min, double scale_max, Vector2 size)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            byte* native_fmt;
            int fmt_byteCount = 0;
                fmt_byteCount = Encoding.UTF8.GetByteCount("%g");
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8("%g", native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            ImPlotNative.ImPlot_ColormapScale(native_label, scale_min, scale_max, size, cmap, native_fmt);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static void ColormapScale(string label, double scale_min, double scale_max, Vector2 size, ImPlotColormap cmap)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_fmt;
            int fmt_byteCount = 0;
                fmt_byteCount = Encoding.UTF8.GetByteCount("%g");
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8("%g", native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            ImPlotNative.ImPlot_ColormapScale(native_label, scale_min, scale_max, size, cmap, native_fmt);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static void ColormapScale(string label, double scale_min, double scale_max, Vector2 size, ImPlotColormap cmap, string fmt)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_ColormapScale(native_label, scale_min, scale_max, size, cmap, native_fmt);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static bool ColormapSlider(string label, ref float t)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            Vector4* @out = null;
            byte* native_format;
            int format_byteCount = 0;
                format_byteCount = Encoding.UTF8.GetByteCount("");
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8("", native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            fixed (float* native_t = &t)
            {
                byte ret = ImPlotNative.ImPlot_ColormapSlider(native_label, native_t, @out, native_format, cmap);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label);
                }
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_format);
                }
                return ret != 0;
            }
        }
        public static bool ColormapSlider(string label, ref float t, out Vector4 @out)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
                format_byteCount = Encoding.UTF8.GetByteCount("");
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8("", native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            fixed (float* native_t = &t)
            {
                fixed (Vector4* native_out = &@out)
                {
                    byte ret = ImPlotNative.ImPlot_ColormapSlider(native_label, native_t, native_out, native_format, cmap);
                    if (label_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label);
                    }
                    if (format_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_format);
                    }
                    return ret != 0;
                }
            }
        }
        public static bool ColormapSlider(string label, ref float t, out Vector4 @out, string format)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
            if (format != null)
            {
                format_byteCount = Encoding.UTF8.GetByteCount(format);
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8(format, native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            }
            else { native_format = null; }
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            fixed (float* native_t = &t)
            {
                fixed (Vector4* native_out = &@out)
                {
                    byte ret = ImPlotNative.ImPlot_ColormapSlider(native_label, native_t, native_out, native_format, cmap);
                    if (label_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label);
                    }
                    if (format_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_format);
                    }
                    return ret != 0;
                }
            }
        }
        public static bool ColormapSlider(string label, ref float t, out Vector4 @out, string format, ImPlotColormap cmap)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
            if (format != null)
            {
                format_byteCount = Encoding.UTF8.GetByteCount(format);
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8(format, native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            }
            else { native_format = null; }
            fixed (float* native_t = &t)
            {
                fixed (Vector4* native_out = &@out)
                {
                    byte ret = ImPlotNative.ImPlot_ColormapSlider(native_label, native_t, native_out, native_format, cmap);
                    if (label_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label);
                    }
                    if (format_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_format);
                    }
                    return ret != 0;
                }
            }
        }
        public static IntPtr CreateContext()
        {
            IntPtr ret = ImPlotNative.ImPlot_CreateContext();
            return ret;
        }
        public static void DestroyContext()
        {
            IntPtr ctx = IntPtr.Zero;
            ImPlotNative.ImPlot_DestroyContext(ctx);
        }
        public static void DestroyContext(IntPtr ctx)
        {
            ImPlotNative.ImPlot_DestroyContext(ctx);
        }
        public static bool DragLineX(string id, ref double x_value)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte show_label = 1;
            Vector4 col = new Vector4(0, 0, 0, -1);
            float thickness = 1;
            fixed (double* native_x_value = &x_value)
            {
                byte ret = ImPlotNative.ImPlot_DragLineX(native_id, native_x_value, show_label, col, thickness);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_id);
                }
                return ret != 0;
            }
        }
        public static bool DragLineX(string id, ref double x_value, bool show_label)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte native_show_label = show_label ? (byte)1 : (byte)0;
            Vector4 col = new Vector4(0, 0, 0, -1);
            float thickness = 1;
            fixed (double* native_x_value = &x_value)
            {
                byte ret = ImPlotNative.ImPlot_DragLineX(native_id, native_x_value, native_show_label, col, thickness);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_id);
                }
                return ret != 0;
            }
        }
        public static bool DragLineX(string id, ref double x_value, bool show_label, Vector4 col)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte native_show_label = show_label ? (byte)1 : (byte)0;
            float thickness = 1;
            fixed (double* native_x_value = &x_value)
            {
                byte ret = ImPlotNative.ImPlot_DragLineX(native_id, native_x_value, native_show_label, col, thickness);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_id);
                }
                return ret != 0;
            }
        }
        public static bool DragLineX(string id, ref double x_value, bool show_label, Vector4 col, float thickness)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte native_show_label = show_label ? (byte)1 : (byte)0;
            fixed (double* native_x_value = &x_value)
            {
                byte ret = ImPlotNative.ImPlot_DragLineX(native_id, native_x_value, native_show_label, col, thickness);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_id);
                }
                return ret != 0;
            }
        }
        public static bool DragLineY(string id, ref double y_value)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte show_label = 1;
            Vector4 col = new Vector4(0, 0, 0, -1);
            float thickness = 1;
            fixed (double* native_y_value = &y_value)
            {
                byte ret = ImPlotNative.ImPlot_DragLineY(native_id, native_y_value, show_label, col, thickness);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_id);
                }
                return ret != 0;
            }
        }
        public static bool DragLineY(string id, ref double y_value, bool show_label)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte native_show_label = show_label ? (byte)1 : (byte)0;
            Vector4 col = new Vector4(0, 0, 0, -1);
            float thickness = 1;
            fixed (double* native_y_value = &y_value)
            {
                byte ret = ImPlotNative.ImPlot_DragLineY(native_id, native_y_value, native_show_label, col, thickness);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_id);
                }
                return ret != 0;
            }
        }
        public static bool DragLineY(string id, ref double y_value, bool show_label, Vector4 col)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte native_show_label = show_label ? (byte)1 : (byte)0;
            float thickness = 1;
            fixed (double* native_y_value = &y_value)
            {
                byte ret = ImPlotNative.ImPlot_DragLineY(native_id, native_y_value, native_show_label, col, thickness);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_id);
                }
                return ret != 0;
            }
        }
        public static bool DragLineY(string id, ref double y_value, bool show_label, Vector4 col, float thickness)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte native_show_label = show_label ? (byte)1 : (byte)0;
            fixed (double* native_y_value = &y_value)
            {
                byte ret = ImPlotNative.ImPlot_DragLineY(native_id, native_y_value, native_show_label, col, thickness);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_id);
                }
                return ret != 0;
            }
        }
        public static bool DragPoint(string id, ref double x, ref double y)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte show_label = 1;
            Vector4 col = new Vector4(0, 0, 0, -1);
            float radius = 4;
            fixed (double* native_x = &x)
            {
                fixed (double* native_y = &y)
                {
                    byte ret = ImPlotNative.ImPlot_DragPoint(native_id, native_x, native_y, show_label, col, radius);
                    if (id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_id);
                    }
                    return ret != 0;
                }
            }
        }
        public static bool DragPoint(string id, ref double x, ref double y, bool show_label)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte native_show_label = show_label ? (byte)1 : (byte)0;
            Vector4 col = new Vector4(0, 0, 0, -1);
            float radius = 4;
            fixed (double* native_x = &x)
            {
                fixed (double* native_y = &y)
                {
                    byte ret = ImPlotNative.ImPlot_DragPoint(native_id, native_x, native_y, native_show_label, col, radius);
                    if (id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_id);
                    }
                    return ret != 0;
                }
            }
        }
        public static bool DragPoint(string id, ref double x, ref double y, bool show_label, Vector4 col)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte native_show_label = show_label ? (byte)1 : (byte)0;
            float radius = 4;
            fixed (double* native_x = &x)
            {
                fixed (double* native_y = &y)
                {
                    byte ret = ImPlotNative.ImPlot_DragPoint(native_id, native_x, native_y, native_show_label, col, radius);
                    if (id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_id);
                    }
                    return ret != 0;
                }
            }
        }
        public static bool DragPoint(string id, ref double x, ref double y, bool show_label, Vector4 col, float radius)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte native_show_label = show_label ? (byte)1 : (byte)0;
            fixed (double* native_x = &x)
            {
                fixed (double* native_y = &y)
                {
                    byte ret = ImPlotNative.ImPlot_DragPoint(native_id, native_x, native_y, native_show_label, col, radius);
                    if (id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_id);
                    }
                    return ret != 0;
                }
            }
        }
        public static void EndDragDropSource()
        {
            ImPlotNative.ImPlot_EndDragDropSource();
        }
        public static void EndDragDropTarget()
        {
            ImPlotNative.ImPlot_EndDragDropTarget();
        }
        public static void EndLegendPopup()
        {
            ImPlotNative.ImPlot_EndLegendPopup();
        }
        public static void EndPlot()
        {
            ImPlotNative.ImPlot_EndPlot();
        }
        public static void FitNextPlotAxes()
        {
            byte x = 1;
            byte y = 1;
            byte y2 = 1;
            byte y3 = 1;
            ImPlotNative.ImPlot_FitNextPlotAxes(x, y, y2, y3);
        }
        public static void FitNextPlotAxes(bool x)
        {
            byte native_x = x ? (byte)1 : (byte)0;
            byte y = 1;
            byte y2 = 1;
            byte y3 = 1;
            ImPlotNative.ImPlot_FitNextPlotAxes(native_x, y, y2, y3);
        }
        public static void FitNextPlotAxes(bool x, bool y)
        {
            byte native_x = x ? (byte)1 : (byte)0;
            byte native_y = y ? (byte)1 : (byte)0;
            byte y2 = 1;
            byte y3 = 1;
            ImPlotNative.ImPlot_FitNextPlotAxes(native_x, native_y, y2, y3);
        }
        public static void FitNextPlotAxes(bool x, bool y, bool y2)
        {
            byte native_x = x ? (byte)1 : (byte)0;
            byte native_y = y ? (byte)1 : (byte)0;
            byte native_y2 = y2 ? (byte)1 : (byte)0;
            byte y3 = 1;
            ImPlotNative.ImPlot_FitNextPlotAxes(native_x, native_y, native_y2, y3);
        }
        public static void FitNextPlotAxes(bool x, bool y, bool y2, bool y3)
        {
            byte native_x = x ? (byte)1 : (byte)0;
            byte native_y = y ? (byte)1 : (byte)0;
            byte native_y2 = y2 ? (byte)1 : (byte)0;
            byte native_y3 = y3 ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_FitNextPlotAxes(native_x, native_y, native_y2, native_y3);
        }
        public static Vector4 GetColormapColor(int idx)
        {
            Vector4 __retval;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            ImPlotNative.ImPlot_GetColormapColor(&__retval, idx, cmap);
            return __retval;
        }
        public static Vector4 GetColormapColor(int idx, ImPlotColormap cmap)
        {
            Vector4 __retval;
            ImPlotNative.ImPlot_GetColormapColor(&__retval, idx, cmap);
            return __retval;
        }
        public static int GetColormapCount()
        {
            int ret = ImPlotNative.ImPlot_GetColormapCount();
            return ret;
        }
        public static ImPlotColormap GetColormapIndex(string name)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            ImPlotColormap ret = ImPlotNative.ImPlot_GetColormapIndex(native_name);
            if (name_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_name);
            }
            return ret;
        }
        public static string GetColormapName(ImPlotColormap cmap)
        {
            byte* ret = ImPlotNative.ImPlot_GetColormapName(cmap);
            return Util.StringFromPtr(ret);
        }
        public static int GetColormapSize()
        {
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            int ret = ImPlotNative.ImPlot_GetColormapSize(cmap);
            return ret;
        }
        public static int GetColormapSize(ImPlotColormap cmap)
        {
            int ret = ImPlotNative.ImPlot_GetColormapSize(cmap);
            return ret;
        }
        public static IntPtr GetCurrentContext()
        {
            IntPtr ret = ImPlotNative.ImPlot_GetCurrentContext();
            return ret;
        }
        public static Vector4 GetLastItemColor()
        {
            Vector4 __retval;
            ImPlotNative.ImPlot_GetLastItemColor(&__retval);
            return __retval;
        }
        public static string GetMarkerName(ImPlotMarker idx)
        {
            byte* ret = ImPlotNative.ImPlot_GetMarkerName(idx);
            return Util.StringFromPtr(ret);
        }
        public static ImDrawListPtr GetPlotDrawList()
        {
            ImDrawList* ret = ImPlotNative.ImPlot_GetPlotDrawList();
            return new ImDrawListPtr(ret);
        }
        public static ImPlotLimits GetPlotLimits()
        {
            ImPlotLimits __retval;
            ImPlotYAxis y_axis = (ImPlotYAxis)(-1);
            ImPlotNative.ImPlot_GetPlotLimits(&__retval, y_axis);
            return __retval;
        }
        public static ImPlotLimits GetPlotLimits(ImPlotYAxis y_axis)
        {
            ImPlotLimits __retval;
            ImPlotNative.ImPlot_GetPlotLimits(&__retval, y_axis);
            return __retval;
        }
        public static ImPlotPoint GetPlotMousePos()
        {
            ImPlotPoint __retval;
            ImPlotYAxis y_axis = (ImPlotYAxis)(-1);
            ImPlotNative.ImPlot_GetPlotMousePos(&__retval, y_axis);
            return __retval;
        }
        public static ImPlotPoint GetPlotMousePos(ImPlotYAxis y_axis)
        {
            ImPlotPoint __retval;
            ImPlotNative.ImPlot_GetPlotMousePos(&__retval, y_axis);
            return __retval;
        }
        public static Vector2 GetPlotPos()
        {
            Vector2 __retval;
            ImPlotNative.ImPlot_GetPlotPos(&__retval);
            return __retval;
        }
        public static ImPlotLimits GetPlotQuery()
        {
            ImPlotLimits __retval;
            ImPlotYAxis y_axis = (ImPlotYAxis)(-1);
            ImPlotNative.ImPlot_GetPlotQuery(&__retval, y_axis);
            return __retval;
        }
        public static ImPlotLimits GetPlotQuery(ImPlotYAxis y_axis)
        {
            ImPlotLimits __retval;
            ImPlotNative.ImPlot_GetPlotQuery(&__retval, y_axis);
            return __retval;
        }
        public static ImPlotLimits GetPlotSelection()
        {
            ImPlotLimits __retval;
            ImPlotYAxis y_axis = (ImPlotYAxis)(-1);
            ImPlotNative.ImPlot_GetPlotSelection(&__retval, y_axis);
            return __retval;
        }
        public static ImPlotLimits GetPlotSelection(ImPlotYAxis y_axis)
        {
            ImPlotLimits __retval;
            ImPlotNative.ImPlot_GetPlotSelection(&__retval, y_axis);
            return __retval;
        }
        public static Vector2 GetPlotSize()
        {
            Vector2 __retval;
            ImPlotNative.ImPlot_GetPlotSize(&__retval);
            return __retval;
        }
        public static ImPlotStylePtr GetStyle()
        {
            ImPlotStyle* ret = ImPlotNative.ImPlot_GetStyle();
            return new ImPlotStylePtr(ret);
        }
        public static string GetStyleColorName(ImPlotCol idx)
        {
            byte* ret = ImPlotNative.ImPlot_GetStyleColorName(idx);
            return Util.StringFromPtr(ret);
        }
        public static void HideNextItem()
        {
            byte hidden = 1;
            ImGuiCond cond = ImGuiCond.Once;
            ImPlotNative.ImPlot_HideNextItem(hidden, cond);
        }
        public static void HideNextItem(bool hidden)
        {
            byte native_hidden = hidden ? (byte)1 : (byte)0;
            ImGuiCond cond = ImGuiCond.Once;
            ImPlotNative.ImPlot_HideNextItem(native_hidden, cond);
        }
        public static void HideNextItem(bool hidden, ImGuiCond cond)
        {
            byte native_hidden = hidden ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_HideNextItem(native_hidden, cond);
        }
        public static bool IsLegendEntryHovered(string label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte ret = ImPlotNative.ImPlot_IsLegendEntryHovered(native_label_id);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool IsPlotHovered()
        {
            byte ret = ImPlotNative.ImPlot_IsPlotHovered();
            return ret != 0;
        }
        public static bool IsPlotQueried()
        {
            byte ret = ImPlotNative.ImPlot_IsPlotQueried();
            return ret != 0;
        }
        public static bool IsPlotSelected()
        {
            byte ret = ImPlotNative.ImPlot_IsPlotSelected();
            return ret != 0;
        }
        public static bool IsPlotXAxisHovered()
        {
            byte ret = ImPlotNative.ImPlot_IsPlotXAxisHovered();
            return ret != 0;
        }
        public static bool IsPlotYAxisHovered()
        {
            ImPlotYAxis y_axis = (ImPlotYAxis)0;
            byte ret = ImPlotNative.ImPlot_IsPlotYAxisHovered(y_axis);
            return ret != 0;
        }
        public static bool IsPlotYAxisHovered(ImPlotYAxis y_axis)
        {
            byte ret = ImPlotNative.ImPlot_IsPlotYAxisHovered(y_axis);
            return ret != 0;
        }
        public static void ItemIcon(Vector4 col)
        {
            ImPlotNative.ImPlot_ItemIcon_Vec4(col);
        }
        public static void ItemIcon(uint col)
        {
            ImPlotNative.ImPlot_ItemIcon_U32(col);
        }
        public static void LinkNextPlotLimits(ref double xmin, ref double xmax, ref double ymin, ref double ymax)
        {
            double* ymin2 = null;
            double* ymax2 = null;
            double* ymin3 = null;
            double* ymax3 = null;
            fixed (double* native_xmin = &xmin)
            {
                fixed (double* native_xmax = &xmax)
                {
                    fixed (double* native_ymin = &ymin)
                    {
                        fixed (double* native_ymax = &ymax)
                        {
                            ImPlotNative.ImPlot_LinkNextPlotLimits(native_xmin, native_xmax, native_ymin, native_ymax, ymin2, ymax2, ymin3, ymax3);
                        }
                    }
                }
            }
        }
        public static void LinkNextPlotLimits(ref double xmin, ref double xmax, ref double ymin, ref double ymax, ref double ymin2)
        {
            double* ymax2 = null;
            double* ymin3 = null;
            double* ymax3 = null;
            fixed (double* native_xmin = &xmin)
            {
                fixed (double* native_xmax = &xmax)
                {
                    fixed (double* native_ymin = &ymin)
                    {
                        fixed (double* native_ymax = &ymax)
                        {
                            fixed (double* native_ymin2 = &ymin2)
                            {
                                ImPlotNative.ImPlot_LinkNextPlotLimits(native_xmin, native_xmax, native_ymin, native_ymax, native_ymin2, ymax2, ymin3, ymax3);
                            }
                        }
                    }
                }
            }
        }
        public static void LinkNextPlotLimits(ref double xmin, ref double xmax, ref double ymin, ref double ymax, ref double ymin2, ref double ymax2)
        {
            double* ymin3 = null;
            double* ymax3 = null;
            fixed (double* native_xmin = &xmin)
            {
                fixed (double* native_xmax = &xmax)
                {
                    fixed (double* native_ymin = &ymin)
                    {
                        fixed (double* native_ymax = &ymax)
                        {
                            fixed (double* native_ymin2 = &ymin2)
                            {
                                fixed (double* native_ymax2 = &ymax2)
                                {
                                    ImPlotNative.ImPlot_LinkNextPlotLimits(native_xmin, native_xmax, native_ymin, native_ymax, native_ymin2, native_ymax2, ymin3, ymax3);
                                }
                            }
                        }
                    }
                }
            }
        }
        public static void LinkNextPlotLimits(ref double xmin, ref double xmax, ref double ymin, ref double ymax, ref double ymin2, ref double ymax2, ref double ymin3)
        {
            double* ymax3 = null;
            fixed (double* native_xmin = &xmin)
            {
                fixed (double* native_xmax = &xmax)
                {
                    fixed (double* native_ymin = &ymin)
                    {
                        fixed (double* native_ymax = &ymax)
                        {
                            fixed (double* native_ymin2 = &ymin2)
                            {
                                fixed (double* native_ymax2 = &ymax2)
                                {
                                    fixed (double* native_ymin3 = &ymin3)
                                    {
                                        ImPlotNative.ImPlot_LinkNextPlotLimits(native_xmin, native_xmax, native_ymin, native_ymax, native_ymin2, native_ymax2, native_ymin3, ymax3);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        public static void LinkNextPlotLimits(ref double xmin, ref double xmax, ref double ymin, ref double ymax, ref double ymin2, ref double ymax2, ref double ymin3, ref double ymax3)
        {
            fixed (double* native_xmin = &xmin)
            {
                fixed (double* native_xmax = &xmax)
                {
                    fixed (double* native_ymin = &ymin)
                    {
                        fixed (double* native_ymax = &ymax)
                        {
                            fixed (double* native_ymin2 = &ymin2)
                            {
                                fixed (double* native_ymax2 = &ymax2)
                                {
                                    fixed (double* native_ymin3 = &ymin3)
                                    {
                                        fixed (double* native_ymax3 = &ymax3)
                                        {
                                            ImPlotNative.ImPlot_LinkNextPlotLimits(native_xmin, native_xmax, native_ymin, native_ymax, native_ymin2, native_ymax2, native_ymin3, native_ymax3);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        public static Vector4 NextColormapColor()
        {
            Vector4 __retval;
            ImPlotNative.ImPlot_NextColormapColor(&__retval);
            return __retval;
        }
        public static ImPlotPoint PixelsToPlot(Vector2 pix)
        {
            ImPlotPoint __retval;
            ImPlotYAxis y_axis = (ImPlotYAxis)(-1);
            ImPlotNative.ImPlot_PixelsToPlot_Vec2(&__retval, pix, y_axis);
            return __retval;
        }
        public static ImPlotPoint PixelsToPlot(Vector2 pix, ImPlotYAxis y_axis)
        {
            ImPlotPoint __retval;
            ImPlotNative.ImPlot_PixelsToPlot_Vec2(&__retval, pix, y_axis);
            return __retval;
        }
        public static ImPlotPoint PixelsToPlot(float x, float y)
        {
            ImPlotPoint __retval;
            ImPlotYAxis y_axis = (ImPlotYAxis)(-1);
            ImPlotNative.ImPlot_PixelsToPlot_Float(&__retval, x, y, y_axis);
            return __retval;
        }
        public static ImPlotPoint PixelsToPlot(float x, float y, ImPlotYAxis y_axis)
        {
            ImPlotPoint __retval;
            ImPlotNative.ImPlot_PixelsToPlot_Float(&__retval, x, y, y_axis);
            return __retval;
        }
        public static void PlotBars(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref float values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref float values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref float values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref float values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref double values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref double values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref double values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref double values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref byte values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref byte values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref byte values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref byte values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref short values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref short values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref short values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref short values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref int values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref int values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref int values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref int values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref uint values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref uint values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref uint values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref uint values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref long values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref long values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref long values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref long values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref float xs, ref float ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref float xs, ref float ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref float xs, ref float ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref double xs, ref double ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref double xs, ref double ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref double xs, ref double ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte xs, ref sbyte ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte xs, ref sbyte ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte xs, ref sbyte ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref byte xs, ref byte ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref byte xs, ref byte ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref byte xs, ref byte ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref short xs, ref short ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref short xs, ref short ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref short xs, ref short ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort xs, ref ushort ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort xs, ref ushort ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort xs, ref ushort ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref int xs, ref int ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref int xs, ref int ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref int xs, ref int ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref uint xs, ref uint ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref uint xs, ref uint ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref uint xs, ref uint ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref long xs, ref long ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref long xs, ref long ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref long xs, ref long ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong xs, ref ulong ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong xs, ref ulong ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong xs, ref ulong ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_FloatPtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref float values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_FloatPtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref float values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_FloatPtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref float values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_FloatPtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref float values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_FloatPtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_doublePtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref double values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_doublePtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref double values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_doublePtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref double values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_doublePtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref double values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_doublePtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref sbyte values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref sbyte values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref sbyte values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref sbyte values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref byte values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref byte values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref byte values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref byte values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref short values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref short values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref short values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref short values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ushort values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ushort values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ushort values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ushort values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref int values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref int values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref int values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref int values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref uint values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref uint values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref uint values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref uint values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref long values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref long values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref long values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref long values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_S64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ulong values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ulong values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ulong values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ulong values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsH_U64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref float xs, ref float ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref float xs, ref float ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref float xs, ref float ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref double xs, ref double ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref double xs, ref double ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref double xs, ref double ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref sbyte xs, ref sbyte ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref sbyte xs, ref sbyte ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref sbyte xs, ref sbyte ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref byte xs, ref byte ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref byte xs, ref byte ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref byte xs, ref byte ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref short xs, ref short ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref short xs, ref short ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref short xs, ref short ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ushort xs, ref ushort ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ushort xs, ref ushort ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ushort xs, ref ushort ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref int xs, ref int ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref int xs, ref int ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref int xs, ref int ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref uint xs, ref uint ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref uint xs, ref uint ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref uint xs, ref uint ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref long xs, ref long ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref long xs, ref long ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref long xs, ref long ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ulong xs, ref ulong ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ulong xs, ref ulong ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ulong xs, ref ulong ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsH_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_FloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref float xs, ref float ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_FloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref float xs, ref float ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_FloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_doublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref double xs, ref double ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_doublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref double xs, ref double ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_doublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref sbyte xs, ref sbyte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref sbyte xs, ref sbyte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref byte xs, ref byte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref byte xs, ref byte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref short xs, ref short ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref short xs, ref short ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ushort xs, ref ushort ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ushort xs, ref ushort ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref int xs, ref int ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref int xs, ref int ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref uint xs, ref uint ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref uint xs, ref uint ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref long xs, ref long ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref long xs, ref long ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ulong xs, ref ulong ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ulong xs, ref ulong ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDummy(string label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotNative.ImPlot_PlotDummy(native_label_id);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref float xs, ref float ys, ref float err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_FloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref float xs, ref float ys, ref float err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_FloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref float xs, ref float ys, ref float err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_FloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref double xs, ref double ys, ref double err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_doublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref double xs, ref double ys, ref double err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_doublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref double xs, ref double ys, ref double err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_doublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_S8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_S8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_S8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref byte xs, ref byte ys, ref byte err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_U8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref byte xs, ref byte ys, ref byte err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_U8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref byte xs, ref byte ys, ref byte err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_U8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref short xs, ref short ys, ref short err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_S16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref short xs, ref short ys, ref short err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_S16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref short xs, ref short ys, ref short err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_S16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_U16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_U16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_U16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref int xs, ref int ys, ref int err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_S32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref int xs, ref int ys, ref int err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_S32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref int xs, ref int ys, ref int err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_S32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref uint xs, ref uint ys, ref uint err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_U32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref uint xs, ref uint ys, ref uint err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_U32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref uint xs, ref uint ys, ref uint err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_U32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref long xs, ref long ys, ref long err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_S64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref long xs, ref long ys, ref long err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_S64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref long xs, ref long ys, ref long err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_S64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_U64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_U64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsH_U64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_FloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_FloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_FloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_doublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_doublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_doublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_S8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_S8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_S8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_U8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_U8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_U8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_S16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_S16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_S16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_U16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_U16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_U16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_S32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_S32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_S32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_U32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_U32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_U32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_S64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_S64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_S64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_U64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_U64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsH_U64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static double PlotHistogram(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int) ImPlotBin.Sturges;
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref float values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref float values, int count, int bins, bool cumulative)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, native_cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref float values, int count, int bins, bool cumulative, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref float values, int count, int bins, bool cumulative, bool density, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref float values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            double bar_scale = 1.0;
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref float values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int) ImPlotBin.Sturges;
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref double values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref double values, int count, int bins, bool cumulative)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, native_cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref double values, int count, int bins, bool cumulative, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref double values, int count, int bins, bool cumulative, bool density, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref double values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            double bar_scale = 1.0;
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref double values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int) ImPlotBin.Sturges;
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref sbyte values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref sbyte values, int count, int bins, bool cumulative)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, native_cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref sbyte values, int count, int bins, bool cumulative, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref sbyte values, int count, int bins, bool cumulative, bool density, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref sbyte values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            double bar_scale = 1.0;
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref sbyte values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int) ImPlotBin.Sturges;
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref byte values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref byte values, int count, int bins, bool cumulative)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, native_cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref byte values, int count, int bins, bool cumulative, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref byte values, int count, int bins, bool cumulative, bool density, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref byte values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            double bar_scale = 1.0;
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref byte values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int) ImPlotBin.Sturges;
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref short values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref short values, int count, int bins, bool cumulative)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, native_cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref short values, int count, int bins, bool cumulative, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref short values, int count, int bins, bool cumulative, bool density, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref short values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            double bar_scale = 1.0;
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref short values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int) ImPlotBin.Sturges;
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ushort values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ushort values, int count, int bins, bool cumulative)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, native_cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ushort values, int count, int bins, bool cumulative, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ushort values, int count, int bins, bool cumulative, bool density, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ushort values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            double bar_scale = 1.0;
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ushort values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int) ImPlotBin.Sturges;
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref int values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref int values, int count, int bins, bool cumulative)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, native_cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref int values, int count, int bins, bool cumulative, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref int values, int count, int bins, bool cumulative, bool density, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref int values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            double bar_scale = 1.0;
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref int values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int) ImPlotBin.Sturges;
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref uint values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref uint values, int count, int bins, bool cumulative)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, native_cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref uint values, int count, int bins, bool cumulative, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref uint values, int count, int bins, bool cumulative, bool density, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref uint values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            double bar_scale = 1.0;
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref uint values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int) ImPlotBin.Sturges;
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref long values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref long values, int count, int bins, bool cumulative)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, native_cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref long values, int count, int bins, bool cumulative, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref long values, int count, int bins, bool cumulative, bool density, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref long values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            double bar_scale = 1.0;
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref long values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int) ImPlotBin.Sturges;
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ulong values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte cumulative = 0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ulong values, int count, int bins, bool cumulative)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte density = 0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, native_cumulative, density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ulong values, int count, int bins, bool cumulative, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotRange range = default;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ulong values, int count, int bins, bool cumulative, bool density, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            double bar_scale = 1.0;
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ulong values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            double bar_scale = 1.0;
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram(string label_id, ref ulong values, int count, int bins, bool cumulative, bool density, ImPlotRange range, bool outliers, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_cumulative = cumulative ? (byte)1 : (byte)0;
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, native_cumulative, native_density, range, native_outliers, bar_scale);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
        public static double PlotHistogram2D(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int) ImPlotBin.Sturges;
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref float xs, ref float ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref float xs, ref float ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref float xs, ref float ys, int count, int x_bins, int y_bins, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref float xs, ref float ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref float xs, ref float ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, native_outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int) ImPlotBin.Sturges;
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref double xs, ref double ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref double xs, ref double ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref double xs, ref double ys, int count, int x_bins, int y_bins, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref double xs, ref double ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref double xs, ref double ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, native_outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int) ImPlotBin.Sturges;
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref sbyte xs, ref sbyte ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref sbyte xs, ref sbyte ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref sbyte xs, ref sbyte ys, int count, int x_bins, int y_bins, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref sbyte xs, ref sbyte ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref sbyte xs, ref sbyte ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, native_outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int) ImPlotBin.Sturges;
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref byte xs, ref byte ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref byte xs, ref byte ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref byte xs, ref byte ys, int count, int x_bins, int y_bins, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref byte xs, ref byte ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref byte xs, ref byte ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, native_outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int) ImPlotBin.Sturges;
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref short xs, ref short ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref short xs, ref short ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref short xs, ref short ys, int count, int x_bins, int y_bins, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref short xs, ref short ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref short xs, ref short ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, native_outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int) ImPlotBin.Sturges;
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ushort xs, ref ushort ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ushort xs, ref ushort ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ushort xs, ref ushort ys, int count, int x_bins, int y_bins, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ushort xs, ref ushort ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ushort xs, ref ushort ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, native_outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int) ImPlotBin.Sturges;
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref int xs, ref int ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref int xs, ref int ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref int xs, ref int ys, int count, int x_bins, int y_bins, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref int xs, ref int ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref int xs, ref int ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, native_outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int) ImPlotBin.Sturges;
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref uint xs, ref uint ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref uint xs, ref uint ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref uint xs, ref uint ys, int count, int x_bins, int y_bins, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref uint xs, ref uint ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref uint xs, ref uint ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, native_outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int) ImPlotBin.Sturges;
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref long xs, ref long ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref long xs, ref long ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref long xs, ref long ys, int count, int x_bins, int y_bins, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref long xs, ref long ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref long xs, ref long ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, native_outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int) ImPlotBin.Sturges;
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ulong xs, ref ulong ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int) ImPlotBin.Sturges;
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ulong xs, ref ulong ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte density = 0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ulong xs, ref ulong ys, int count, int x_bins, int y_bins, bool density)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            ImPlotLimits range = default;
            byte outliers = 1;
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ulong xs, ref ulong ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte outliers = 1;
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static double PlotHistogram2D(string label_id, ref ulong xs, ref ulong ys, int count, int x_bins, int y_bins, bool density, ImPlotLimits range, bool outliers)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte native_density = density ? (byte)1 : (byte)0;
            byte native_outliers = outliers ? (byte)1 : (byte)0;
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, native_density, range, native_outliers);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
        public static void PlotHLines(string label_id, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_FloatPtr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref float ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_FloatPtr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref float ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_FloatPtr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_doublePtr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref double ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_doublePtr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref double ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_doublePtr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_S8Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref sbyte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_S8Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref sbyte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_S8Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_U8Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref byte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_U8Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref byte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_U8Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_S16Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref short ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_S16Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref short ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_S16Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_U16Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref ushort ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_U16Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref ushort ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_U16Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_S32Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref int ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_S32Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref int ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_S32Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_U32Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref uint ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_U32Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref uint ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_U32Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_S64Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref long ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_S64Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref long ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_S64Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_U64Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref ulong ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_U64Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref ulong ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLines_U64Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotImage(string label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            Vector2 uv0 = new Vector2();
            Vector2 uv1 = new Vector2(1, 1);
            Vector4 tint_col = new Vector4(1, 1, 1, 1);
            ImPlotNative.ImPlot_PlotImage(native_label_id, user_texture_id, bounds_min, bounds_max, uv0, uv1, tint_col);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotImage(string label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            Vector2 uv1 = new Vector2(1, 1);
            Vector4 tint_col = new Vector4(1, 1, 1, 1);
            ImPlotNative.ImPlot_PlotImage(native_label_id, user_texture_id, bounds_min, bounds_max, uv0, uv1, tint_col);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotImage(string label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0, Vector2 uv1)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            Vector4 tint_col = new Vector4(1, 1, 1, 1);
            ImPlotNative.ImPlot_PlotImage(native_label_id, user_texture_id, bounds_min, bounds_max, uv0, uv1, tint_col);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotImage(string label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0, Vector2 uv1, Vector4 tint_col)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotNative.ImPlot_PlotImage(native_label_id, user_texture_id, bounds_min, bounds_max, uv0, uv1, tint_col);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotLine(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref float values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref float values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref float values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref float values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref double values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref double values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref double values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref double values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref byte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref byte values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref byte values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref byte values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref short values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref short values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref short values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref short values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref int values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref int values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref int values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref int values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref uint values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref uint values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref uint values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref uint values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref long values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref long values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref long values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref long values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref float xs, ref float ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref float xs, ref float ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref double xs, ref double ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref double xs, ref double ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte xs, ref sbyte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte xs, ref sbyte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref byte xs, ref byte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref byte xs, ref byte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref short xs, ref short ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref short xs, ref short ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort xs, ref ushort ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort xs, ref ushort ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref int xs, ref int ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref int xs, ref int ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref uint xs, ref uint ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref uint xs, ref uint ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref long xs, ref long ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref long xs, ref long ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong xs, ref ulong ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong xs, ref ulong ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_FloatPtr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_FloatPtr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_FloatPtr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_FloatPtr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_doublePtr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_doublePtr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_doublePtr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_doublePtr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S8Ptr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S8Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S8Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S8Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U8Ptr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U8Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U8Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U8Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S16Ptr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S16Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S16Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S16Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U16Ptr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U16Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U16Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U16Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S32Ptr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S32Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S32Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S32Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U32Ptr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U32Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U32Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U32Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S64Ptr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S64Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S64Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S64Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U64Ptr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U64Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U64Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U64Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotScatter(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref float values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref float values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref float values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref float values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref double values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref double values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref double values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref double values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref short values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref short values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref short values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref short values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref int values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref int values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref int values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref int values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref long values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref long values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref long values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref long values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref float xs, ref float ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref float xs, ref float ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref double xs, ref double ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref double xs, ref double ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte xs, ref sbyte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte xs, ref sbyte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte xs, ref byte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte xs, ref byte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref short xs, ref short ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref short xs, ref short ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort xs, ref ushort ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort xs, ref ushort ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref int xs, ref int ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref int xs, ref int ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint xs, ref uint ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint xs, ref uint ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref long xs, ref long ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref long xs, ref long ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong xs, ref ulong ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong xs, ref ulong ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref float values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref float values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref float values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref float values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref float values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref double values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref double values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref double values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref double values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref double values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref short values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref short values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref short values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref short values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref short values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref int values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref int values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref int values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref int values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref int values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref long values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref long values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref long values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref long values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref long values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys1, ref float ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys1 = &ys1)
                {
                    fixed (float* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys1, ref float ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys1 = &ys1)
                {
                    fixed (float* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys1, ref float ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys1 = &ys1)
                {
                    fixed (float* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys1, ref double ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys1 = &ys1)
                {
                    fixed (double* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys1, ref double ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys1 = &ys1)
                {
                    fixed (double* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys1, ref double ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys1 = &ys1)
                {
                    fixed (double* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys1, ref sbyte ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys1 = &ys1)
                {
                    fixed (sbyte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys1, ref sbyte ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys1 = &ys1)
                {
                    fixed (sbyte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys1, ref sbyte ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys1 = &ys1)
                {
                    fixed (sbyte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys1, ref byte ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys1 = &ys1)
                {
                    fixed (byte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys1, ref byte ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys1 = &ys1)
                {
                    fixed (byte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys1, ref byte ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys1 = &ys1)
                {
                    fixed (byte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys1, ref short ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys1 = &ys1)
                {
                    fixed (short* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys1, ref short ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys1 = &ys1)
                {
                    fixed (short* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys1, ref short ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys1 = &ys1)
                {
                    fixed (short* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys1, ref ushort ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys1 = &ys1)
                {
                    fixed (ushort* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys1, ref ushort ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys1 = &ys1)
                {
                    fixed (ushort* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys1, ref ushort ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys1 = &ys1)
                {
                    fixed (ushort* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys1, ref int ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys1 = &ys1)
                {
                    fixed (int* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys1, ref int ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys1 = &ys1)
                {
                    fixed (int* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys1, ref int ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys1 = &ys1)
                {
                    fixed (int* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys1, ref uint ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys1 = &ys1)
                {
                    fixed (uint* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys1, ref uint ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys1 = &ys1)
                {
                    fixed (uint* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys1, ref uint ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys1 = &ys1)
                {
                    fixed (uint* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys1, ref long ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys1 = &ys1)
                {
                    fixed (long* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys1, ref long ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys1 = &ys1)
                {
                    fixed (long* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys1, ref long ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys1 = &ys1)
                {
                    fixed (long* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys1, ref ulong ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys1 = &ys1)
                {
                    fixed (ulong* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys1, ref ulong ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys1 = &ys1)
                {
                    fixed (ulong* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys1, ref ulong ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys1 = &ys1)
                {
                    fixed (ulong* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref float values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref float values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref float values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref float values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref double values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref double values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref double values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref double values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref short values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref short values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref short values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref short values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref int values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref int values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref int values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref int values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref long values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref long values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref long values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref long values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref float xs, ref float ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref float xs, ref float ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref double xs, ref double ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref double xs, ref double ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte xs, ref sbyte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte xs, ref sbyte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte xs, ref byte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte xs, ref byte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref short xs, ref short ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref short xs, ref short ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort xs, ref ushort ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort xs, ref ushort ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref int xs, ref int ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref int xs, ref int ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint xs, ref uint ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint xs, ref uint ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref long xs, ref long ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref long xs, ref long ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong xs, ref ulong ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong xs, ref ulong ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref float values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref float values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref float values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref float values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref float values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref double values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref double values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref double values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref double values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref double values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref byte values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref byte values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref byte values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref byte values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref byte values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref short values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref short values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref short values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref short values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref short values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref int values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref int values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref int values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref int values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref int values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref uint values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref uint values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref uint values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref uint values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref uint values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref long values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref long values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref long values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref long values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref long values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref float xs, ref float ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref float xs, ref float ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref float xs, ref float ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref double xs, ref double ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref double xs, ref double ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref double xs, ref double ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte xs, ref sbyte ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte xs, ref sbyte ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte xs, ref sbyte ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref byte xs, ref byte ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref byte xs, ref byte ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref byte xs, ref byte ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref short xs, ref short ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref short xs, ref short ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref short xs, ref short ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort xs, ref ushort ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort xs, ref ushort ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort xs, ref ushort ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref int xs, ref int ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref int xs, ref int ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref int xs, ref int ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref uint xs, ref uint ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref uint xs, ref uint ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref uint xs, ref uint ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref long xs, ref long ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref long xs, ref long ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref long xs, ref long ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong xs, ref ulong ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong xs, ref ulong ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong xs, ref ulong ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotText(string text, double x, double y)
        {
            byte* native_text;
            int text_byteCount = 0;
            if (text != null)
            {
                text_byteCount = Encoding.UTF8.GetByteCount(text);
                if (text_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_text = Util.Allocate(text_byteCount + 1);
                }
                else
                {
                    byte* native_text_stackBytes = stackalloc byte[text_byteCount + 1];
                    native_text = native_text_stackBytes;
                }
                int native_text_offset = Util.GetUtf8(text, native_text, text_byteCount);
                native_text[native_text_offset] = 0;
            }
            else { native_text = null; }
            byte vertical = 0;
            Vector2 pix_offset = new Vector2();
            ImPlotNative.ImPlot_PlotText(native_text, x, y, vertical, pix_offset);
            if (text_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_text);
            }
        }
        public static void PlotText(string text, double x, double y, bool vertical)
        {
            byte* native_text;
            int text_byteCount = 0;
            if (text != null)
            {
                text_byteCount = Encoding.UTF8.GetByteCount(text);
                if (text_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_text = Util.Allocate(text_byteCount + 1);
                }
                else
                {
                    byte* native_text_stackBytes = stackalloc byte[text_byteCount + 1];
                    native_text = native_text_stackBytes;
                }
                int native_text_offset = Util.GetUtf8(text, native_text, text_byteCount);
                native_text[native_text_offset] = 0;
            }
            else { native_text = null; }
            byte native_vertical = vertical ? (byte)1 : (byte)0;
            Vector2 pix_offset = new Vector2();
            ImPlotNative.ImPlot_PlotText(native_text, x, y, native_vertical, pix_offset);
            if (text_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_text);
            }
        }
        public static void PlotText(string text, double x, double y, bool vertical, Vector2 pix_offset)
        {
            byte* native_text;
            int text_byteCount = 0;
            if (text != null)
            {
                text_byteCount = Encoding.UTF8.GetByteCount(text);
                if (text_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_text = Util.Allocate(text_byteCount + 1);
                }
                else
                {
                    byte* native_text_stackBytes = stackalloc byte[text_byteCount + 1];
                    native_text = native_text_stackBytes;
                }
                int native_text_offset = Util.GetUtf8(text, native_text, text_byteCount);
                native_text[native_text_offset] = 0;
            }
            else { native_text = null; }
            byte native_vertical = vertical ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_PlotText(native_text, x, y, native_vertical, pix_offset);
            if (text_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_text);
            }
        }
        public static Vector2 PlotToPixels(ImPlotPoint plt)
        {
            Vector2 __retval;
            ImPlotYAxis y_axis = (ImPlotYAxis)(-1);
            ImPlotNative.ImPlot_PlotToPixels_PlotPoInt(&__retval, plt, y_axis);
            return __retval;
        }
        public static Vector2 PlotToPixels(ImPlotPoint plt, ImPlotYAxis y_axis)
        {
            Vector2 __retval;
            ImPlotNative.ImPlot_PlotToPixels_PlotPoInt(&__retval, plt, y_axis);
            return __retval;
        }
        public static Vector2 PlotToPixels(double x, double y)
        {
            Vector2 __retval;
            ImPlotYAxis y_axis = (ImPlotYAxis)(-1);
            ImPlotNative.ImPlot_PlotToPixels_double(&__retval, x, y, y_axis);
            return __retval;
        }
        public static Vector2 PlotToPixels(double x, double y, ImPlotYAxis y_axis)
        {
            Vector2 __retval;
            ImPlotNative.ImPlot_PlotToPixels_double(&__retval, x, y, y_axis);
            return __retval;
        }
        public static void PlotVLines(string label_id, ref float xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_FloatPtr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref float xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_FloatPtr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref float xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_FloatPtr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref double xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_doublePtr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref double xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_doublePtr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref double xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_doublePtr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref sbyte xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_S8Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref sbyte xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_S8Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref sbyte xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_S8Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref byte xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_U8Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref byte xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_U8Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref byte xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_U8Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref short xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_S16Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref short xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_S16Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref short xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_S16Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref ushort xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_U16Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref ushort xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_U16Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref ushort xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_U16Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref int xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_S32Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref int xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_S32Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref int xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_S32Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref uint xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_U32Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref uint xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_U32Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref uint xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_U32Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref long xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_S64Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref long xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_S64Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref long xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_S64Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref ulong xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_U64Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref ulong xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_U64Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref ulong xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLines_U64Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PopColormap()
        {
            int count = 1;
            ImPlotNative.ImPlot_PopColormap(count);
        }
        public static void PopColormap(int count)
        {
            ImPlotNative.ImPlot_PopColormap(count);
        }
        public static void PopPlotClipRect()
        {
            ImPlotNative.ImPlot_PopPlotClipRect();
        }
        public static void PopStyleColor()
        {
            int count = 1;
            ImPlotNative.ImPlot_PopStyleColor(count);
        }
        public static void PopStyleColor(int count)
        {
            ImPlotNative.ImPlot_PopStyleColor(count);
        }
        public static void PopStyleVar()
        {
            int count = 1;
            ImPlotNative.ImPlot_PopStyleVar(count);
        }
        public static void PopStyleVar(int count)
        {
            ImPlotNative.ImPlot_PopStyleVar(count);
        }
        public static void PushColormap(ImPlotColormap cmap)
        {
            ImPlotNative.ImPlot_PushColormap_PlotColormap(cmap);
        }
        public static void PushColormap(string name)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            ImPlotNative.ImPlot_PushColormap_Str(native_name);
            if (name_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_name);
            }
        }
        public static void PushPlotClipRect()
        {
            float expand = 0;
            ImPlotNative.ImPlot_PushPlotClipRect(expand);
        }
        public static void PushPlotClipRect(float expand)
        {
            ImPlotNative.ImPlot_PushPlotClipRect(expand);
        }
        public static void PushStyleColor(ImPlotCol idx, uint col)
        {
            ImPlotNative.ImPlot_PushStyleColor_U32(idx, col);
        }
        public static void PushStyleColor(ImPlotCol idx, Vector4 col)
        {
            ImPlotNative.ImPlot_PushStyleColor_Vec4(idx, col);
        }
        public static void PushStyleVar(ImPlotStyleVar idx, float val)
        {
            ImPlotNative.ImPlot_PushStyleVar_Float(idx, val);
        }
        public static void PushStyleVar(ImPlotStyleVar idx, int val)
        {
            ImPlotNative.ImPlot_PushStyleVar_Int(idx, val);
        }
        public static void PushStyleVar(ImPlotStyleVar idx, Vector2 val)
        {
            ImPlotNative.ImPlot_PushStyleVar_Vec2(idx, val);
        }
        public static Vector4 SampleColormap(float t)
        {
            Vector4 __retval;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            ImPlotNative.ImPlot_SampleColormap(&__retval, t, cmap);
            return __retval;
        }
        public static Vector4 SampleColormap(float t, ImPlotColormap cmap)
        {
            Vector4 __retval;
            ImPlotNative.ImPlot_SampleColormap(&__retval, t, cmap);
            return __retval;
        }
        public static void SetCurrentContext(IntPtr ctx)
        {
            ImPlotNative.ImPlot_SetCurrentContext(ctx);
        }
        public static void SetImGuiContext(IntPtr ctx)
        {
            ImPlotNative.ImPlot_SetImGuiContext(ctx);
        }
        public static void SetLegendLocation(ImPlotLocation location)
        {
            ImPlotOrientation orientation = ImPlotOrientation.Vertical;
            byte outside = 0;
            ImPlotNative.ImPlot_SetLegendLocation(location, orientation, outside);
        }
        public static void SetLegendLocation(ImPlotLocation location, ImPlotOrientation orientation)
        {
            byte outside = 0;
            ImPlotNative.ImPlot_SetLegendLocation(location, orientation, outside);
        }
        public static void SetLegendLocation(ImPlotLocation location, ImPlotOrientation orientation, bool outside)
        {
            byte native_outside = outside ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_SetLegendLocation(location, orientation, native_outside);
        }
        public static void SetMousePosLocation(ImPlotLocation location)
        {
            ImPlotNative.ImPlot_SetMousePosLocation(location);
        }
        public static void SetNextErrorBarStyle()
        {
            Vector4 col = new Vector4(0, 0, 0, -1);
            float size = -1;
            float weight = -1;
            ImPlotNative.ImPlot_SetNextErrorBarStyle(col, size, weight);
        }
        public static void SetNextErrorBarStyle(Vector4 col)
        {
            float size = -1;
            float weight = -1;
            ImPlotNative.ImPlot_SetNextErrorBarStyle(col, size, weight);
        }
        public static void SetNextErrorBarStyle(Vector4 col, float size)
        {
            float weight = -1;
            ImPlotNative.ImPlot_SetNextErrorBarStyle(col, size, weight);
        }
        public static void SetNextErrorBarStyle(Vector4 col, float size, float weight)
        {
            ImPlotNative.ImPlot_SetNextErrorBarStyle(col, size, weight);
        }
        public static void SetNextFillStyle()
        {
            Vector4 col = new Vector4(0, 0, 0, -1);
            float alpha_mod = -1;
            ImPlotNative.ImPlot_SetNextFillStyle(col, alpha_mod);
        }
        public static void SetNextFillStyle(Vector4 col)
        {
            float alpha_mod = -1;
            ImPlotNative.ImPlot_SetNextFillStyle(col, alpha_mod);
        }
        public static void SetNextFillStyle(Vector4 col, float alpha_mod)
        {
            ImPlotNative.ImPlot_SetNextFillStyle(col, alpha_mod);
        }
        public static void SetNextLineStyle()
        {
            Vector4 col = new Vector4(0, 0, 0, -1);
            float weight = -1;
            ImPlotNative.ImPlot_SetNextLineStyle(col, weight);
        }
        public static void SetNextLineStyle(Vector4 col)
        {
            float weight = -1;
            ImPlotNative.ImPlot_SetNextLineStyle(col, weight);
        }
        public static void SetNextLineStyle(Vector4 col, float weight)
        {
            ImPlotNative.ImPlot_SetNextLineStyle(col, weight);
        }
        public static void SetNextMarkerStyle()
        {
            ImPlotMarker marker = (ImPlotMarker)(-1);
            float size = -1;
            Vector4 fill = new Vector4(0, 0, 0, -1);
            float weight = -1;
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker)
        {
            float size = -1;
            Vector4 fill = new Vector4(0, 0, 0, -1);
            float weight = -1;
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker, float size)
        {
            Vector4 fill = new Vector4(0, 0, 0, -1);
            float weight = -1;
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker, float size, Vector4 fill)
        {
            float weight = -1;
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker, float size, Vector4 fill, float weight)
        {
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker, float size, Vector4 fill, float weight, Vector4 outline)
        {
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextPlotFormatX(string fmt)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_SetNextPlotFormatX(native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static void SetNextPlotFormatY(string fmt)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotYAxis y_axis = ImPlotYAxis._1;
            ImPlotNative.ImPlot_SetNextPlotFormatY(native_fmt, y_axis);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static void SetNextPlotFormatY(string fmt, ImPlotYAxis y_axis)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_SetNextPlotFormatY(native_fmt, y_axis);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static void SetNextPlotLimits(double xmin, double xmax, double ymin, double ymax)
        {
            ImGuiCond cond = ImGuiCond.Once;
            ImPlotNative.ImPlot_SetNextPlotLimits(xmin, xmax, ymin, ymax, cond);
        }
        public static void SetNextPlotLimits(double xmin, double xmax, double ymin, double ymax, ImGuiCond cond)
        {
            ImPlotNative.ImPlot_SetNextPlotLimits(xmin, xmax, ymin, ymax, cond);
        }
        public static void SetNextPlotLimitsX(double xmin, double xmax)
        {
            ImGuiCond cond = ImGuiCond.Once;
            ImPlotNative.ImPlot_SetNextPlotLimitsX(xmin, xmax, cond);
        }
        public static void SetNextPlotLimitsX(double xmin, double xmax, ImGuiCond cond)
        {
            ImPlotNative.ImPlot_SetNextPlotLimitsX(xmin, xmax, cond);
        }
        public static void SetNextPlotLimitsY(double ymin, double ymax)
        {
            ImGuiCond cond = ImGuiCond.Once;
            ImPlotYAxis y_axis = ImPlotYAxis._1;
            ImPlotNative.ImPlot_SetNextPlotLimitsY(ymin, ymax, cond, y_axis);
        }
        public static void SetNextPlotLimitsY(double ymin, double ymax, ImGuiCond cond)
        {
            ImPlotYAxis y_axis = ImPlotYAxis._1;
            ImPlotNative.ImPlot_SetNextPlotLimitsY(ymin, ymax, cond, y_axis);
        }
        public static void SetNextPlotLimitsY(double ymin, double ymax, ImGuiCond cond, ImPlotYAxis y_axis)
        {
            ImPlotNative.ImPlot_SetNextPlotLimitsY(ymin, ymax, cond, y_axis);
        }
        public static void SetNextPlotTicksX(ref double values, int n_ticks)
        {
            byte** labels = null;
            byte keep_default = 0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetNextPlotTicksX_doublePtr(native_values, n_ticks, labels, keep_default);
            }
        }
        public static void SetNextPlotTicksX(ref double values, int n_ticks, string[] labels)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte keep_default = 0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetNextPlotTicksX_doublePtr(native_values, n_ticks, native_labels, keep_default);
            }
        }
        public static void SetNextPlotTicksX(ref double values, int n_ticks, string[] labels, bool keep_default)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte native_keep_default = keep_default ? (byte)1 : (byte)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetNextPlotTicksX_doublePtr(native_values, n_ticks, native_labels, native_keep_default);
            }
        }
        public static void SetNextPlotTicksX(double x_min, double x_max, int n_ticks)
        {
            byte** labels = null;
            byte keep_default = 0;
            ImPlotNative.ImPlot_SetNextPlotTicksX_double(x_min, x_max, n_ticks, labels, keep_default);
        }
        public static void SetNextPlotTicksX(double x_min, double x_max, int n_ticks, string[] labels)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte keep_default = 0;
            ImPlotNative.ImPlot_SetNextPlotTicksX_double(x_min, x_max, n_ticks, native_labels, keep_default);
        }
        public static void SetNextPlotTicksX(double x_min, double x_max, int n_ticks, string[] labels, bool keep_default)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte native_keep_default = keep_default ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_SetNextPlotTicksX_double(x_min, x_max, n_ticks, native_labels, native_keep_default);
        }
        public static void SetNextPlotTicksY(ref double values, int n_ticks)
        {
            byte** labels = null;
            byte keep_default = 0;
            ImPlotYAxis y_axis = ImPlotYAxis._1;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetNextPlotTicksY_doublePtr(native_values, n_ticks, labels, keep_default, y_axis);
            }
        }
        public static void SetNextPlotTicksY(ref double values, int n_ticks, string[] labels)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte keep_default = 0;
            ImPlotYAxis y_axis = ImPlotYAxis._1;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetNextPlotTicksY_doublePtr(native_values, n_ticks, native_labels, keep_default, y_axis);
            }
        }
        public static void SetNextPlotTicksY(ref double values, int n_ticks, string[] labels, bool keep_default)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte native_keep_default = keep_default ? (byte)1 : (byte)0;
            ImPlotYAxis y_axis = ImPlotYAxis._1;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetNextPlotTicksY_doublePtr(native_values, n_ticks, native_labels, native_keep_default, y_axis);
            }
        }
        public static void SetNextPlotTicksY(ref double values, int n_ticks, string[] labels, bool keep_default, ImPlotYAxis y_axis)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte native_keep_default = keep_default ? (byte)1 : (byte)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetNextPlotTicksY_doublePtr(native_values, n_ticks, native_labels, native_keep_default, y_axis);
            }
        }
        public static void SetNextPlotTicksY(double y_min, double y_max, int n_ticks)
        {
            byte** labels = null;
            byte keep_default = 0;
            ImPlotYAxis y_axis = ImPlotYAxis._1;
            ImPlotNative.ImPlot_SetNextPlotTicksY_double(y_min, y_max, n_ticks, labels, keep_default, y_axis);
        }
        public static void SetNextPlotTicksY(double y_min, double y_max, int n_ticks, string[] labels)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte keep_default = 0;
            ImPlotYAxis y_axis = ImPlotYAxis._1;
            ImPlotNative.ImPlot_SetNextPlotTicksY_double(y_min, y_max, n_ticks, native_labels, keep_default, y_axis);
        }
        public static void SetNextPlotTicksY(double y_min, double y_max, int n_ticks, string[] labels, bool keep_default)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte native_keep_default = keep_default ? (byte)1 : (byte)0;
            ImPlotYAxis y_axis = ImPlotYAxis._1;
            ImPlotNative.ImPlot_SetNextPlotTicksY_double(y_min, y_max, n_ticks, native_labels, native_keep_default, y_axis);
        }
        public static void SetNextPlotTicksY(double y_min, double y_max, int n_ticks, string[] labels, bool keep_default, ImPlotYAxis y_axis)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte native_keep_default = keep_default ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_SetNextPlotTicksY_double(y_min, y_max, n_ticks, native_labels, native_keep_default, y_axis);
        }
        public static void SetPlotQuery(ImPlotLimits query)
        {
            ImPlotYAxis y_axis = (ImPlotYAxis)(-1);
            ImPlotNative.ImPlot_SetPlotQuery(query, y_axis);
        }
        public static void SetPlotQuery(ImPlotLimits query, ImPlotYAxis y_axis)
        {
            ImPlotNative.ImPlot_SetPlotQuery(query, y_axis);
        }
        public static void SetPlotYAxis(ImPlotYAxis y_axis)
        {
            ImPlotNative.ImPlot_SetPlotYAxis(y_axis);
        }
        public static bool ShowColormapSelector(string label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte ret = ImPlotNative.ImPlot_ShowColormapSelector(native_label);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
        public static void ShowDemoWindow()
        {
            byte* p_open = null;
            ImPlotNative.ImPlot_ShowDemoWindow(p_open);
        }
        public static void ShowDemoWindow(ref bool p_open)
        {
            byte native_p_open_val = p_open ? (byte)1 : (byte)0;
            byte* native_p_open = &native_p_open_val;
            ImPlotNative.ImPlot_ShowDemoWindow(native_p_open);
            p_open = native_p_open_val != 0;
        }
        public static void ShowMetricsWindow()
        {
            byte* p_popen = null;
            ImPlotNative.ImPlot_ShowMetricsWindow(p_popen);
        }
        public static void ShowMetricsWindow(ref bool p_popen)
        {
            byte native_p_popen_val = p_popen ? (byte)1 : (byte)0;
            byte* native_p_popen = &native_p_popen_val;
            ImPlotNative.ImPlot_ShowMetricsWindow(native_p_popen);
            p_popen = native_p_popen_val != 0;
        }
        public static void ShowStyleEditor()
        {
            ImPlotStyle* @ref = null;
            ImPlotNative.ImPlot_ShowStyleEditor(@ref);
        }
        public static void ShowStyleEditor(ImPlotStylePtr @ref)
        {
            ImPlotStyle* native_ref = @ref.NativePtr;
            ImPlotNative.ImPlot_ShowStyleEditor(native_ref);
        }
        public static bool ShowStyleSelector(string label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte ret = ImPlotNative.ImPlot_ShowStyleSelector(native_label);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
        public static void ShowUserGuide()
        {
            ImPlotNative.ImPlot_ShowUserGuide();
        }
        public static void StyleColorsAuto()
        {
            ImPlotStyle* dst = null;
            ImPlotNative.ImPlot_StyleColorsAuto(dst);
        }
        public static void StyleColorsAuto(ImPlotStylePtr dst)
        {
            ImPlotStyle* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_StyleColorsAuto(native_dst);
        }
        public static void StyleColorsClassic()
        {
            ImPlotStyle* dst = null;
            ImPlotNative.ImPlot_StyleColorsClassic(dst);
        }
        public static void StyleColorsClassic(ImPlotStylePtr dst)
        {
            ImPlotStyle* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_StyleColorsClassic(native_dst);
        }
        public static void StyleColorsDark()
        {
            ImPlotStyle* dst = null;
            ImPlotNative.ImPlot_StyleColorsDark(dst);
        }
        public static void StyleColorsDark(ImPlotStylePtr dst)
        {
            ImPlotStyle* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_StyleColorsDark(native_dst);
        }
        public static void StyleColorsLight()
        {
            ImPlotStyle* dst = null;
            ImPlotNative.ImPlot_StyleColorsLight(dst);
        }
        public static void StyleColorsLight(ImPlotStylePtr dst)
        {
            ImPlotStyle* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_StyleColorsLight(native_dst);
        }
    }
}

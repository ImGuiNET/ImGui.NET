using System;
using System.Numerics;
using System.Runtime.InteropServices;
using System.Text;
using ImGuiNET;

namespace ImPlotNET
{
    public static unsafe partial class ImPlot
    {
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static ImPlotColormap AddColormap(ReadOnlySpan<char> name, ref Vector4 cols, int size)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            byte qual = 1;
            fixed (Vector4* native_cols = &cols)
            {
                ImPlotColormap ret = ImPlotNative.ImPlot_AddColormap_Vec4Ptr(native_name, native_cols, size, qual);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_name);
                }
                return ret;
            }
        }
#endif
        public static ImPlotColormap AddColormap(string name, ref Vector4 cols, int size)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            byte qual = 1;
            fixed (Vector4* native_cols = &cols)
            {
                ImPlotColormap ret = ImPlotNative.ImPlot_AddColormap_Vec4Ptr(native_name, native_cols, size, qual);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_name);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static ImPlotColormap AddColormap(ReadOnlySpan<char> name, ref Vector4 cols, int size, bool qual)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            byte native_qual = qual ? (byte)1 : (byte)0;
            fixed (Vector4* native_cols = &cols)
            {
                ImPlotColormap ret = ImPlotNative.ImPlot_AddColormap_Vec4Ptr(native_name, native_cols, size, native_qual);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_name);
                }
                return ret;
            }
        }
#endif
        public static ImPlotColormap AddColormap(string name, ref Vector4 cols, int size, bool qual)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            byte native_qual = qual ? (byte)1 : (byte)0;
            fixed (Vector4* native_cols = &cols)
            {
                ImPlotColormap ret = ImPlotNative.ImPlot_AddColormap_Vec4Ptr(native_name, native_cols, size, native_qual);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_name);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static ImPlotColormap AddColormap(ReadOnlySpan<char> name, ref uint cols, int size)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            byte qual = 1;
            fixed (uint* native_cols = &cols)
            {
                ImPlotColormap ret = ImPlotNative.ImPlot_AddColormap_U32Ptr(native_name, native_cols, size, qual);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_name);
                }
                return ret;
            }
        }
#endif
        public static ImPlotColormap AddColormap(string name, ref uint cols, int size)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            byte qual = 1;
            fixed (uint* native_cols = &cols)
            {
                ImPlotColormap ret = ImPlotNative.ImPlot_AddColormap_U32Ptr(native_name, native_cols, size, qual);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_name);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static ImPlotColormap AddColormap(ReadOnlySpan<char> name, ref uint cols, int size, bool qual)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            byte native_qual = qual ? (byte)1 : (byte)0;
            fixed (uint* native_cols = &cols)
            {
                ImPlotColormap ret = ImPlotNative.ImPlot_AddColormap_U32Ptr(native_name, native_cols, size, native_qual);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_name);
                }
                return ret;
            }
        }
#endif
        public static ImPlotColormap AddColormap(string name, ref uint cols, int size, bool qual)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            byte native_qual = qual ? (byte)1 : (byte)0;
            fixed (uint* native_cols = &cols)
            {
                ImPlotColormap ret = ImPlotNative.ImPlot_AddColormap_U32Ptr(native_name, native_cols, size, native_qual);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_name);
                }
                return ret;
            }
        }
        public static void Annotation(double x, double y, Vector4 col, Vector2 pix_offset, bool clamp)
        {
            byte native_clamp = clamp ? (byte)1 : (byte)0;
            byte round = 0;
            ImPlotNative.ImPlot_Annotation_Bool(x, y, col, pix_offset, native_clamp, round);
        }
        public static void Annotation(double x, double y, Vector4 col, Vector2 pix_offset, bool clamp, bool round)
        {
            byte native_clamp = clamp ? (byte)1 : (byte)0;
            byte native_round = round ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_Annotation_Bool(x, y, col, pix_offset, native_clamp, native_round);
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void Annotation(double x, double y, Vector4 col, Vector2 pix_offset, bool clamp, ReadOnlySpan<char> fmt)
        {
            byte native_clamp = clamp ? (byte)1 : (byte)0;
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_Annotation_Str(x, y, col, pix_offset, native_clamp, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
#endif
        public static void Annotation(double x, double y, Vector4 col, Vector2 pix_offset, bool clamp, string fmt)
        {
            byte native_clamp = clamp ? (byte)1 : (byte)0;
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_Annotation_Str(x, y, col, pix_offset, native_clamp, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool BeginAlignedPlots(ReadOnlySpan<char> group_id)
        {
            byte* native_group_id;
            int group_id_byteCount = 0;
            if (group_id != null)
            {
                group_id_byteCount = Encoding.UTF8.GetByteCount(group_id);
                if (group_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_group_id = Util.Allocate(group_id_byteCount + 1);
                }
                else
                {
                    byte* native_group_id_stackBytes = stackalloc byte[group_id_byteCount + 1];
                    native_group_id = native_group_id_stackBytes;
                }
                int native_group_id_offset = Util.GetUtf8(group_id, native_group_id, group_id_byteCount);
                native_group_id[native_group_id_offset] = 0;
            }
            else { native_group_id = null; }
            byte vertical = 1;
            byte ret = ImPlotNative.ImPlot_BeginAlignedPlots(native_group_id, vertical);
            if (group_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_group_id);
            }
            return ret != 0;
        }
#endif
        public static bool BeginAlignedPlots(string group_id)
        {
            byte* native_group_id;
            int group_id_byteCount = 0;
            if (group_id != null)
            {
                group_id_byteCount = Encoding.UTF8.GetByteCount(group_id);
                if (group_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_group_id = Util.Allocate(group_id_byteCount + 1);
                }
                else
                {
                    byte* native_group_id_stackBytes = stackalloc byte[group_id_byteCount + 1];
                    native_group_id = native_group_id_stackBytes;
                }
                int native_group_id_offset = Util.GetUtf8(group_id, native_group_id, group_id_byteCount);
                native_group_id[native_group_id_offset] = 0;
            }
            else { native_group_id = null; }
            byte vertical = 1;
            byte ret = ImPlotNative.ImPlot_BeginAlignedPlots(native_group_id, vertical);
            if (group_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_group_id);
            }
            return ret != 0;
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool BeginAlignedPlots(ReadOnlySpan<char> group_id, bool vertical)
        {
            byte* native_group_id;
            int group_id_byteCount = 0;
            if (group_id != null)
            {
                group_id_byteCount = Encoding.UTF8.GetByteCount(group_id);
                if (group_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_group_id = Util.Allocate(group_id_byteCount + 1);
                }
                else
                {
                    byte* native_group_id_stackBytes = stackalloc byte[group_id_byteCount + 1];
                    native_group_id = native_group_id_stackBytes;
                }
                int native_group_id_offset = Util.GetUtf8(group_id, native_group_id, group_id_byteCount);
                native_group_id[native_group_id_offset] = 0;
            }
            else { native_group_id = null; }
            byte native_vertical = vertical ? (byte)1 : (byte)0;
            byte ret = ImPlotNative.ImPlot_BeginAlignedPlots(native_group_id, native_vertical);
            if (group_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_group_id);
            }
            return ret != 0;
        }
#endif
        public static bool BeginAlignedPlots(string group_id, bool vertical)
        {
            byte* native_group_id;
            int group_id_byteCount = 0;
            if (group_id != null)
            {
                group_id_byteCount = Encoding.UTF8.GetByteCount(group_id);
                if (group_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_group_id = Util.Allocate(group_id_byteCount + 1);
                }
                else
                {
                    byte* native_group_id_stackBytes = stackalloc byte[group_id_byteCount + 1];
                    native_group_id = native_group_id_stackBytes;
                }
                int native_group_id_offset = Util.GetUtf8(group_id, native_group_id, group_id_byteCount);
                native_group_id[native_group_id_offset] = 0;
            }
            else { native_group_id = null; }
            byte native_vertical = vertical ? (byte)1 : (byte)0;
            byte ret = ImPlotNative.ImPlot_BeginAlignedPlots(native_group_id, native_vertical);
            if (group_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_group_id);
            }
            return ret != 0;
        }
        public static bool BeginDragDropSourceAxis(ImAxis axis)
        {
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceAxis(axis, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSourceAxis(ImAxis axis, ImGuiDragDropFlags flags)
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceAxis(axis, flags);
            return ret != 0;
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool BeginDragDropSourceItem(ReadOnlySpan<char> label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceItem(native_label_id, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
#endif
        public static bool BeginDragDropSourceItem(string label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceItem(native_label_id, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool BeginDragDropSourceItem(ReadOnlySpan<char> label_id, ImGuiDragDropFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceItem(native_label_id, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
#endif
        public static bool BeginDragDropSourceItem(string label_id, ImGuiDragDropFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceItem(native_label_id, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool BeginDragDropSourcePlot()
        {
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourcePlot(flags);
            return ret != 0;
        }
        public static bool BeginDragDropSourcePlot(ImGuiDragDropFlags flags)
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourcePlot(flags);
            return ret != 0;
        }
        public static bool BeginDragDropTargetAxis(ImAxis axis)
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropTargetAxis(axis);
            return ret != 0;
        }
        public static bool BeginDragDropTargetLegend()
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropTargetLegend();
            return ret != 0;
        }
        public static bool BeginDragDropTargetPlot()
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropTargetPlot();
            return ret != 0;
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool BeginLegendPopup(ReadOnlySpan<char> label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImGuiMouseButton mouse_button = (ImGuiMouseButton)1;
            byte ret = ImPlotNative.ImPlot_BeginLegendPopup(native_label_id, mouse_button);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
#endif
        public static bool BeginLegendPopup(string label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImGuiMouseButton mouse_button = (ImGuiMouseButton)1;
            byte ret = ImPlotNative.ImPlot_BeginLegendPopup(native_label_id, mouse_button);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool BeginLegendPopup(ReadOnlySpan<char> label_id, ImGuiMouseButton mouse_button)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte ret = ImPlotNative.ImPlot_BeginLegendPopup(native_label_id, mouse_button);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
#endif
        public static bool BeginLegendPopup(string label_id, ImGuiMouseButton mouse_button)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte ret = ImPlotNative.ImPlot_BeginLegendPopup(native_label_id, mouse_button);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool BeginPlot(ReadOnlySpan<char> title_id)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            Vector2 size = new Vector2(-1, 0);
            ImPlotFlags flags = (ImPlotFlags)0;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, size, flags);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            return ret != 0;
        }
#endif
        public static bool BeginPlot(string title_id)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            Vector2 size = new Vector2(-1, 0);
            ImPlotFlags flags = (ImPlotFlags)0;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, size, flags);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            return ret != 0;
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool BeginPlot(ReadOnlySpan<char> title_id, Vector2 size)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            ImPlotFlags flags = (ImPlotFlags)0;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, size, flags);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            return ret != 0;
        }
#endif
        public static bool BeginPlot(string title_id, Vector2 size)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            ImPlotFlags flags = (ImPlotFlags)0;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, size, flags);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            return ret != 0;
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool BeginPlot(ReadOnlySpan<char> title_id, Vector2 size, ImPlotFlags flags)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, size, flags);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            return ret != 0;
        }
#endif
        public static bool BeginPlot(string title_id, Vector2 size, ImPlotFlags flags)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, size, flags);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            return ret != 0;
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool BeginSubplots(ReadOnlySpan<char> title_id, int rows, int cols, Vector2 size)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            ImPlotSubplotFlags flags = (ImPlotSubplotFlags)0;
            float* row_ratios = null;
            float* col_ratios = null;
            byte ret = ImPlotNative.ImPlot_BeginSubplots(native_title_id, rows, cols, size, flags, row_ratios, col_ratios);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            return ret != 0;
        }
#endif
        public static bool BeginSubplots(string title_id, int rows, int cols, Vector2 size)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            ImPlotSubplotFlags flags = (ImPlotSubplotFlags)0;
            float* row_ratios = null;
            float* col_ratios = null;
            byte ret = ImPlotNative.ImPlot_BeginSubplots(native_title_id, rows, cols, size, flags, row_ratios, col_ratios);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            return ret != 0;
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool BeginSubplots(ReadOnlySpan<char> title_id, int rows, int cols, Vector2 size, ImPlotSubplotFlags flags)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            float* row_ratios = null;
            float* col_ratios = null;
            byte ret = ImPlotNative.ImPlot_BeginSubplots(native_title_id, rows, cols, size, flags, row_ratios, col_ratios);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            return ret != 0;
        }
#endif
        public static bool BeginSubplots(string title_id, int rows, int cols, Vector2 size, ImPlotSubplotFlags flags)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            float* row_ratios = null;
            float* col_ratios = null;
            byte ret = ImPlotNative.ImPlot_BeginSubplots(native_title_id, rows, cols, size, flags, row_ratios, col_ratios);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            return ret != 0;
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool BeginSubplots(ReadOnlySpan<char> title_id, int rows, int cols, Vector2 size, ImPlotSubplotFlags flags, ref float row_ratios)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            float* col_ratios = null;
            fixed (float* native_row_ratios = &row_ratios)
            {
                byte ret = ImPlotNative.ImPlot_BeginSubplots(native_title_id, rows, cols, size, flags, native_row_ratios, col_ratios);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_title_id);
                }
                return ret != 0;
            }
        }
#endif
        public static bool BeginSubplots(string title_id, int rows, int cols, Vector2 size, ImPlotSubplotFlags flags, ref float row_ratios)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            float* col_ratios = null;
            fixed (float* native_row_ratios = &row_ratios)
            {
                byte ret = ImPlotNative.ImPlot_BeginSubplots(native_title_id, rows, cols, size, flags, native_row_ratios, col_ratios);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_title_id);
                }
                return ret != 0;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool BeginSubplots(ReadOnlySpan<char> title_id, int rows, int cols, Vector2 size, ImPlotSubplotFlags flags, ref float row_ratios, ref float col_ratios)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            fixed (float* native_row_ratios = &row_ratios)
            {
                fixed (float* native_col_ratios = &col_ratios)
                {
                    byte ret = ImPlotNative.ImPlot_BeginSubplots(native_title_id, rows, cols, size, flags, native_row_ratios, native_col_ratios);
                    if (title_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_title_id);
                    }
                    return ret != 0;
                }
            }
        }
#endif
        public static bool BeginSubplots(string title_id, int rows, int cols, Vector2 size, ImPlotSubplotFlags flags, ref float row_ratios, ref float col_ratios)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            fixed (float* native_row_ratios = &row_ratios)
            {
                fixed (float* native_col_ratios = &col_ratios)
                {
                    byte ret = ImPlotNative.ImPlot_BeginSubplots(native_title_id, rows, cols, size, flags, native_row_ratios, native_col_ratios);
                    if (title_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_title_id);
                    }
                    return ret != 0;
                }
            }
        }
        public static void BustColorCache()
        {
            byte* native_plot_title_id = null;
            ImPlotNative.ImPlot_BustColorCache(native_plot_title_id);
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void BustColorCache(ReadOnlySpan<char> plot_title_id)
        {
            byte* native_plot_title_id;
            int plot_title_id_byteCount = 0;
            if (plot_title_id != null)
            {
                plot_title_id_byteCount = Encoding.UTF8.GetByteCount(plot_title_id);
                if (plot_title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_plot_title_id = Util.Allocate(plot_title_id_byteCount + 1);
                }
                else
                {
                    byte* native_plot_title_id_stackBytes = stackalloc byte[plot_title_id_byteCount + 1];
                    native_plot_title_id = native_plot_title_id_stackBytes;
                }
                int native_plot_title_id_offset = Util.GetUtf8(plot_title_id, native_plot_title_id, plot_title_id_byteCount);
                native_plot_title_id[native_plot_title_id_offset] = 0;
            }
            else { native_plot_title_id = null; }
            ImPlotNative.ImPlot_BustColorCache(native_plot_title_id);
            if (plot_title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_plot_title_id);
            }
        }
#endif
        public static void BustColorCache(string plot_title_id)
        {
            byte* native_plot_title_id;
            int plot_title_id_byteCount = 0;
            if (plot_title_id != null)
            {
                plot_title_id_byteCount = Encoding.UTF8.GetByteCount(plot_title_id);
                if (plot_title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_plot_title_id = Util.Allocate(plot_title_id_byteCount + 1);
                }
                else
                {
                    byte* native_plot_title_id_stackBytes = stackalloc byte[plot_title_id_byteCount + 1];
                    native_plot_title_id = native_plot_title_id_stackBytes;
                }
                int native_plot_title_id_offset = Util.GetUtf8(plot_title_id, native_plot_title_id, plot_title_id_byteCount);
                native_plot_title_id[native_plot_title_id_offset] = 0;
            }
            else { native_plot_title_id = null; }
            ImPlotNative.ImPlot_BustColorCache(native_plot_title_id);
            if (plot_title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_plot_title_id);
            }
        }
        public static void CancelPlotSelection()
        {
            ImPlotNative.ImPlot_CancelPlotSelection();
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool ColormapButton(ReadOnlySpan<char> label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            Vector2 size = new Vector2();
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            byte ret = ImPlotNative.ImPlot_ColormapButton(native_label, size, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
#endif
        public static bool ColormapButton(string label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            Vector2 size = new Vector2();
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            byte ret = ImPlotNative.ImPlot_ColormapButton(native_label, size, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool ColormapButton(ReadOnlySpan<char> label, Vector2 size)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            byte ret = ImPlotNative.ImPlot_ColormapButton(native_label, size, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
#endif
        public static bool ColormapButton(string label, Vector2 size)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            byte ret = ImPlotNative.ImPlot_ColormapButton(native_label, size, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool ColormapButton(ReadOnlySpan<char> label, Vector2 size, ImPlotColormap cmap)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte ret = ImPlotNative.ImPlot_ColormapButton(native_label, size, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
#endif
        public static bool ColormapButton(string label, Vector2 size, ImPlotColormap cmap)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte ret = ImPlotNative.ImPlot_ColormapButton(native_label, size, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
        public static void ColormapIcon(ImPlotColormap cmap)
        {
            ImPlotNative.ImPlot_ColormapIcon(cmap);
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void ColormapScale(ReadOnlySpan<char> label, double scale_min, double scale_max)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            Vector2 size = new Vector2();
            byte* native_format;
            int format_byteCount = 0;
                format_byteCount = Encoding.UTF8.GetByteCount("%g");
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8("%g", native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            ImPlotColormapScaleFlags flags = (ImPlotColormapScaleFlags)0;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            ImPlotNative.ImPlot_ColormapScale(native_label, scale_min, scale_max, size, native_format, flags, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            if (format_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_format);
            }
        }
#endif
        public static void ColormapScale(string label, double scale_min, double scale_max)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            Vector2 size = new Vector2();
            byte* native_format;
            int format_byteCount = 0;
                format_byteCount = Encoding.UTF8.GetByteCount("%g");
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8("%g", native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            ImPlotColormapScaleFlags flags = (ImPlotColormapScaleFlags)0;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            ImPlotNative.ImPlot_ColormapScale(native_label, scale_min, scale_max, size, native_format, flags, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            if (format_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_format);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void ColormapScale(ReadOnlySpan<char> label, double scale_min, double scale_max, Vector2 size)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
                format_byteCount = Encoding.UTF8.GetByteCount("%g");
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8("%g", native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            ImPlotColormapScaleFlags flags = (ImPlotColormapScaleFlags)0;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            ImPlotNative.ImPlot_ColormapScale(native_label, scale_min, scale_max, size, native_format, flags, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            if (format_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_format);
            }
        }
#endif
        public static void ColormapScale(string label, double scale_min, double scale_max, Vector2 size)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
                format_byteCount = Encoding.UTF8.GetByteCount("%g");
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8("%g", native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            ImPlotColormapScaleFlags flags = (ImPlotColormapScaleFlags)0;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            ImPlotNative.ImPlot_ColormapScale(native_label, scale_min, scale_max, size, native_format, flags, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            if (format_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_format);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void ColormapScale(ReadOnlySpan<char> label, double scale_min, double scale_max, Vector2 size, ReadOnlySpan<char> format)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
            if (format != null)
            {
                format_byteCount = Encoding.UTF8.GetByteCount(format);
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8(format, native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            }
            else { native_format = null; }
            ImPlotColormapScaleFlags flags = (ImPlotColormapScaleFlags)0;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            ImPlotNative.ImPlot_ColormapScale(native_label, scale_min, scale_max, size, native_format, flags, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            if (format_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_format);
            }
        }
#endif
        public static void ColormapScale(string label, double scale_min, double scale_max, Vector2 size, string format)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
            if (format != null)
            {
                format_byteCount = Encoding.UTF8.GetByteCount(format);
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8(format, native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            }
            else { native_format = null; }
            ImPlotColormapScaleFlags flags = (ImPlotColormapScaleFlags)0;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            ImPlotNative.ImPlot_ColormapScale(native_label, scale_min, scale_max, size, native_format, flags, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            if (format_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_format);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void ColormapScale(ReadOnlySpan<char> label, double scale_min, double scale_max, Vector2 size, ReadOnlySpan<char> format, ImPlotColormapScaleFlags flags)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
            if (format != null)
            {
                format_byteCount = Encoding.UTF8.GetByteCount(format);
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8(format, native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            }
            else { native_format = null; }
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            ImPlotNative.ImPlot_ColormapScale(native_label, scale_min, scale_max, size, native_format, flags, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            if (format_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_format);
            }
        }
#endif
        public static void ColormapScale(string label, double scale_min, double scale_max, Vector2 size, string format, ImPlotColormapScaleFlags flags)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
            if (format != null)
            {
                format_byteCount = Encoding.UTF8.GetByteCount(format);
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8(format, native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            }
            else { native_format = null; }
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            ImPlotNative.ImPlot_ColormapScale(native_label, scale_min, scale_max, size, native_format, flags, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            if (format_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_format);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void ColormapScale(ReadOnlySpan<char> label, double scale_min, double scale_max, Vector2 size, ReadOnlySpan<char> format, ImPlotColormapScaleFlags flags, ImPlotColormap cmap)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
            if (format != null)
            {
                format_byteCount = Encoding.UTF8.GetByteCount(format);
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8(format, native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            }
            else { native_format = null; }
            ImPlotNative.ImPlot_ColormapScale(native_label, scale_min, scale_max, size, native_format, flags, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            if (format_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_format);
            }
        }
#endif
        public static void ColormapScale(string label, double scale_min, double scale_max, Vector2 size, string format, ImPlotColormapScaleFlags flags, ImPlotColormap cmap)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
            if (format != null)
            {
                format_byteCount = Encoding.UTF8.GetByteCount(format);
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8(format, native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            }
            else { native_format = null; }
            ImPlotNative.ImPlot_ColormapScale(native_label, scale_min, scale_max, size, native_format, flags, cmap);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            if (format_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_format);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool ColormapSlider(ReadOnlySpan<char> label, ref float t)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            Vector4* @out = null;
            byte* native_format;
            int format_byteCount = 0;
                format_byteCount = Encoding.UTF8.GetByteCount("");
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8("", native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            fixed (float* native_t = &t)
            {
                byte ret = ImPlotNative.ImPlot_ColormapSlider(native_label, native_t, @out, native_format, cmap);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label);
                }
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_format);
                }
                return ret != 0;
            }
        }
#endif
        public static bool ColormapSlider(string label, ref float t)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            Vector4* @out = null;
            byte* native_format;
            int format_byteCount = 0;
                format_byteCount = Encoding.UTF8.GetByteCount("");
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8("", native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            fixed (float* native_t = &t)
            {
                byte ret = ImPlotNative.ImPlot_ColormapSlider(native_label, native_t, @out, native_format, cmap);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label);
                }
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_format);
                }
                return ret != 0;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool ColormapSlider(ReadOnlySpan<char> label, ref float t, out Vector4 @out)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
                format_byteCount = Encoding.UTF8.GetByteCount("");
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8("", native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            fixed (float* native_t = &t)
            {
                fixed (Vector4* native_out = &@out)
                {
                    byte ret = ImPlotNative.ImPlot_ColormapSlider(native_label, native_t, native_out, native_format, cmap);
                    if (label_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label);
                    }
                    if (format_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_format);
                    }
                    return ret != 0;
                }
            }
        }
#endif
        public static bool ColormapSlider(string label, ref float t, out Vector4 @out)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
                format_byteCount = Encoding.UTF8.GetByteCount("");
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8("", native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            fixed (float* native_t = &t)
            {
                fixed (Vector4* native_out = &@out)
                {
                    byte ret = ImPlotNative.ImPlot_ColormapSlider(native_label, native_t, native_out, native_format, cmap);
                    if (label_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label);
                    }
                    if (format_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_format);
                    }
                    return ret != 0;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool ColormapSlider(ReadOnlySpan<char> label, ref float t, out Vector4 @out, ReadOnlySpan<char> format)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
            if (format != null)
            {
                format_byteCount = Encoding.UTF8.GetByteCount(format);
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8(format, native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            }
            else { native_format = null; }
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            fixed (float* native_t = &t)
            {
                fixed (Vector4* native_out = &@out)
                {
                    byte ret = ImPlotNative.ImPlot_ColormapSlider(native_label, native_t, native_out, native_format, cmap);
                    if (label_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label);
                    }
                    if (format_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_format);
                    }
                    return ret != 0;
                }
            }
        }
#endif
        public static bool ColormapSlider(string label, ref float t, out Vector4 @out, string format)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
            if (format != null)
            {
                format_byteCount = Encoding.UTF8.GetByteCount(format);
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8(format, native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            }
            else { native_format = null; }
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            fixed (float* native_t = &t)
            {
                fixed (Vector4* native_out = &@out)
                {
                    byte ret = ImPlotNative.ImPlot_ColormapSlider(native_label, native_t, native_out, native_format, cmap);
                    if (label_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label);
                    }
                    if (format_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_format);
                    }
                    return ret != 0;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool ColormapSlider(ReadOnlySpan<char> label, ref float t, out Vector4 @out, ReadOnlySpan<char> format, ImPlotColormap cmap)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
            if (format != null)
            {
                format_byteCount = Encoding.UTF8.GetByteCount(format);
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8(format, native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            }
            else { native_format = null; }
            fixed (float* native_t = &t)
            {
                fixed (Vector4* native_out = &@out)
                {
                    byte ret = ImPlotNative.ImPlot_ColormapSlider(native_label, native_t, native_out, native_format, cmap);
                    if (label_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label);
                    }
                    if (format_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_format);
                    }
                    return ret != 0;
                }
            }
        }
#endif
        public static bool ColormapSlider(string label, ref float t, out Vector4 @out, string format, ImPlotColormap cmap)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte* native_format;
            int format_byteCount = 0;
            if (format != null)
            {
                format_byteCount = Encoding.UTF8.GetByteCount(format);
                if (format_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_format = Util.Allocate(format_byteCount + 1);
                }
                else
                {
                    byte* native_format_stackBytes = stackalloc byte[format_byteCount + 1];
                    native_format = native_format_stackBytes;
                }
                int native_format_offset = Util.GetUtf8(format, native_format, format_byteCount);
                native_format[native_format_offset] = 0;
            }
            else { native_format = null; }
            fixed (float* native_t = &t)
            {
                fixed (Vector4* native_out = &@out)
                {
                    byte ret = ImPlotNative.ImPlot_ColormapSlider(native_label, native_t, native_out, native_format, cmap);
                    if (label_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label);
                    }
                    if (format_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_format);
                    }
                    return ret != 0;
                }
            }
        }
        public static IntPtr CreateContext()
        {
            IntPtr ret = ImPlotNative.ImPlot_CreateContext();
            return ret;
        }
        public static void DestroyContext()
        {
            IntPtr ctx = IntPtr.Zero;
            ImPlotNative.ImPlot_DestroyContext(ctx);
        }
        public static void DestroyContext(IntPtr ctx)
        {
            ImPlotNative.ImPlot_DestroyContext(ctx);
        }
        public static bool DragLineX(int id, ref double x, Vector4 col)
        {
            float thickness = 1;
            ImPlotDragToolFlags flags = (ImPlotDragToolFlags)0;
            fixed (double* native_x = &x)
            {
                byte ret = ImPlotNative.ImPlot_DragLineX(id, native_x, col, thickness, flags);
                return ret != 0;
            }
        }
        public static bool DragLineX(int id, ref double x, Vector4 col, float thickness)
        {
            ImPlotDragToolFlags flags = (ImPlotDragToolFlags)0;
            fixed (double* native_x = &x)
            {
                byte ret = ImPlotNative.ImPlot_DragLineX(id, native_x, col, thickness, flags);
                return ret != 0;
            }
        }
        public static bool DragLineX(int id, ref double x, Vector4 col, float thickness, ImPlotDragToolFlags flags)
        {
            fixed (double* native_x = &x)
            {
                byte ret = ImPlotNative.ImPlot_DragLineX(id, native_x, col, thickness, flags);
                return ret != 0;
            }
        }
        public static bool DragLineY(int id, ref double y, Vector4 col)
        {
            float thickness = 1;
            ImPlotDragToolFlags flags = (ImPlotDragToolFlags)0;
            fixed (double* native_y = &y)
            {
                byte ret = ImPlotNative.ImPlot_DragLineY(id, native_y, col, thickness, flags);
                return ret != 0;
            }
        }
        public static bool DragLineY(int id, ref double y, Vector4 col, float thickness)
        {
            ImPlotDragToolFlags flags = (ImPlotDragToolFlags)0;
            fixed (double* native_y = &y)
            {
                byte ret = ImPlotNative.ImPlot_DragLineY(id, native_y, col, thickness, flags);
                return ret != 0;
            }
        }
        public static bool DragLineY(int id, ref double y, Vector4 col, float thickness, ImPlotDragToolFlags flags)
        {
            fixed (double* native_y = &y)
            {
                byte ret = ImPlotNative.ImPlot_DragLineY(id, native_y, col, thickness, flags);
                return ret != 0;
            }
        }
        public static bool DragPoint(int id, ref double x, ref double y, Vector4 col)
        {
            float size = 4;
            ImPlotDragToolFlags flags = (ImPlotDragToolFlags)0;
            fixed (double* native_x = &x)
            {
                fixed (double* native_y = &y)
                {
                    byte ret = ImPlotNative.ImPlot_DragPoint(id, native_x, native_y, col, size, flags);
                    return ret != 0;
                }
            }
        }
        public static bool DragPoint(int id, ref double x, ref double y, Vector4 col, float size)
        {
            ImPlotDragToolFlags flags = (ImPlotDragToolFlags)0;
            fixed (double* native_x = &x)
            {
                fixed (double* native_y = &y)
                {
                    byte ret = ImPlotNative.ImPlot_DragPoint(id, native_x, native_y, col, size, flags);
                    return ret != 0;
                }
            }
        }
        public static bool DragPoint(int id, ref double x, ref double y, Vector4 col, float size, ImPlotDragToolFlags flags)
        {
            fixed (double* native_x = &x)
            {
                fixed (double* native_y = &y)
                {
                    byte ret = ImPlotNative.ImPlot_DragPoint(id, native_x, native_y, col, size, flags);
                    return ret != 0;
                }
            }
        }
        public static bool DragRect(int id, ref double x1, ref double y1, ref double x2, ref double y2, Vector4 col)
        {
            ImPlotDragToolFlags flags = (ImPlotDragToolFlags)0;
            fixed (double* native_x1 = &x1)
            {
                fixed (double* native_y1 = &y1)
                {
                    fixed (double* native_x2 = &x2)
                    {
                        fixed (double* native_y2 = &y2)
                        {
                            byte ret = ImPlotNative.ImPlot_DragRect(id, native_x1, native_y1, native_x2, native_y2, col, flags);
                            return ret != 0;
                        }
                    }
                }
            }
        }
        public static bool DragRect(int id, ref double x1, ref double y1, ref double x2, ref double y2, Vector4 col, ImPlotDragToolFlags flags)
        {
            fixed (double* native_x1 = &x1)
            {
                fixed (double* native_y1 = &y1)
                {
                    fixed (double* native_x2 = &x2)
                    {
                        fixed (double* native_y2 = &y2)
                        {
                            byte ret = ImPlotNative.ImPlot_DragRect(id, native_x1, native_y1, native_x2, native_y2, col, flags);
                            return ret != 0;
                        }
                    }
                }
            }
        }
        public static void EndAlignedPlots()
        {
            ImPlotNative.ImPlot_EndAlignedPlots();
        }
        public static void EndDragDropSource()
        {
            ImPlotNative.ImPlot_EndDragDropSource();
        }
        public static void EndDragDropTarget()
        {
            ImPlotNative.ImPlot_EndDragDropTarget();
        }
        public static void EndLegendPopup()
        {
            ImPlotNative.ImPlot_EndLegendPopup();
        }
        public static void EndPlot()
        {
            ImPlotNative.ImPlot_EndPlot();
        }
        public static void EndSubplots()
        {
            ImPlotNative.ImPlot_EndSubplots();
        }
        public static Vector4 GetColormapColor(int idx)
        {
            Vector4 __retval;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            ImPlotNative.ImPlot_GetColormapColor(&__retval, idx, cmap);
            return __retval;
        }
        public static Vector4 GetColormapColor(int idx, ImPlotColormap cmap)
        {
            Vector4 __retval;
            ImPlotNative.ImPlot_GetColormapColor(&__retval, idx, cmap);
            return __retval;
        }
        public static int GetColormapCount()
        {
            int ret = ImPlotNative.ImPlot_GetColormapCount();
            return ret;
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static ImPlotColormap GetColormapIndex(ReadOnlySpan<char> name)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            ImPlotColormap ret = ImPlotNative.ImPlot_GetColormapIndex(native_name);
            if (name_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_name);
            }
            return ret;
        }
#endif
        public static ImPlotColormap GetColormapIndex(string name)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            ImPlotColormap ret = ImPlotNative.ImPlot_GetColormapIndex(native_name);
            if (name_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_name);
            }
            return ret;
        }
        public static string GetColormapName(ImPlotColormap cmap)
        {
            byte* ret = ImPlotNative.ImPlot_GetColormapName(cmap);
            return Util.StringFromPtr(ret);
        }
        public static int GetColormapSize()
        {
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            int ret = ImPlotNative.ImPlot_GetColormapSize(cmap);
            return ret;
        }
        public static int GetColormapSize(ImPlotColormap cmap)
        {
            int ret = ImPlotNative.ImPlot_GetColormapSize(cmap);
            return ret;
        }
        public static IntPtr GetCurrentContext()
        {
            IntPtr ret = ImPlotNative.ImPlot_GetCurrentContext();
            return ret;
        }
        public static ImPlotInputMapPtr GetInputMap()
        {
            ImPlotInputMap* ret = ImPlotNative.ImPlot_GetInputMap();
            return new ImPlotInputMapPtr(ret);
        }
        public static Vector4 GetLastItemColor()
        {
            Vector4 __retval;
            ImPlotNative.ImPlot_GetLastItemColor(&__retval);
            return __retval;
        }
        public static string GetMarkerName(ImPlotMarker idx)
        {
            byte* ret = ImPlotNative.ImPlot_GetMarkerName(idx);
            return Util.StringFromPtr(ret);
        }
        public static ImDrawListPtr GetPlotDrawList()
        {
            ImDrawList* ret = ImPlotNative.ImPlot_GetPlotDrawList();
            return new ImDrawListPtr(ret);
        }
        public static ImPlotRect GetPlotLimits()
        {
            ImAxis x_axis = (ImAxis)(-1);
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotRect ret = ImPlotNative.ImPlot_GetPlotLimits(x_axis, y_axis);
            return ret;
        }
        public static ImPlotRect GetPlotLimits(ImAxis x_axis)
        {
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotRect ret = ImPlotNative.ImPlot_GetPlotLimits(x_axis, y_axis);
            return ret;
        }
        public static ImPlotRect GetPlotLimits(ImAxis x_axis, ImAxis y_axis)
        {
            ImPlotRect ret = ImPlotNative.ImPlot_GetPlotLimits(x_axis, y_axis);
            return ret;
        }
        public static ImPlotPoint GetPlotMousePos()
        {
            ImPlotPoint __retval;
            ImAxis x_axis = (ImAxis)(-1);
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_GetPlotMousePos(&__retval, x_axis, y_axis);
            return __retval;
        }
        public static ImPlotPoint GetPlotMousePos(ImAxis x_axis)
        {
            ImPlotPoint __retval;
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_GetPlotMousePos(&__retval, x_axis, y_axis);
            return __retval;
        }
        public static ImPlotPoint GetPlotMousePos(ImAxis x_axis, ImAxis y_axis)
        {
            ImPlotPoint __retval;
            ImPlotNative.ImPlot_GetPlotMousePos(&__retval, x_axis, y_axis);
            return __retval;
        }
        public static Vector2 GetPlotPos()
        {
            Vector2 __retval;
            ImPlotNative.ImPlot_GetPlotPos(&__retval);
            return __retval;
        }
        public static ImPlotRect GetPlotSelection()
        {
            ImAxis x_axis = (ImAxis)(-1);
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotRect ret = ImPlotNative.ImPlot_GetPlotSelection(x_axis, y_axis);
            return ret;
        }
        public static ImPlotRect GetPlotSelection(ImAxis x_axis)
        {
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotRect ret = ImPlotNative.ImPlot_GetPlotSelection(x_axis, y_axis);
            return ret;
        }
        public static ImPlotRect GetPlotSelection(ImAxis x_axis, ImAxis y_axis)
        {
            ImPlotRect ret = ImPlotNative.ImPlot_GetPlotSelection(x_axis, y_axis);
            return ret;
        }
        public static Vector2 GetPlotSize()
        {
            Vector2 __retval;
            ImPlotNative.ImPlot_GetPlotSize(&__retval);
            return __retval;
        }
        public static ImPlotStylePtr GetStyle()
        {
            ImPlotStyle* ret = ImPlotNative.ImPlot_GetStyle();
            return new ImPlotStylePtr(ret);
        }
        public static string GetStyleColorName(ImPlotCol idx)
        {
            byte* ret = ImPlotNative.ImPlot_GetStyleColorName(idx);
            return Util.StringFromPtr(ret);
        }
        public static void HideNextItem()
        {
            byte hidden = 1;
            ImPlotCond cond = ImPlotCond.Once;
            ImPlotNative.ImPlot_HideNextItem(hidden, cond);
        }
        public static void HideNextItem(bool hidden)
        {
            byte native_hidden = hidden ? (byte)1 : (byte)0;
            ImPlotCond cond = ImPlotCond.Once;
            ImPlotNative.ImPlot_HideNextItem(native_hidden, cond);
        }
        public static void HideNextItem(bool hidden, ImPlotCond cond)
        {
            byte native_hidden = hidden ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_HideNextItem(native_hidden, cond);
        }
        public static bool IsAxisHovered(ImAxis axis)
        {
            byte ret = ImPlotNative.ImPlot_IsAxisHovered(axis);
            return ret != 0;
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool IsLegendEntryHovered(ReadOnlySpan<char> label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte ret = ImPlotNative.ImPlot_IsLegendEntryHovered(native_label_id);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
#endif
        public static bool IsLegendEntryHovered(string label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte ret = ImPlotNative.ImPlot_IsLegendEntryHovered(native_label_id);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool IsPlotHovered()
        {
            byte ret = ImPlotNative.ImPlot_IsPlotHovered();
            return ret != 0;
        }
        public static bool IsPlotSelected()
        {
            byte ret = ImPlotNative.ImPlot_IsPlotSelected();
            return ret != 0;
        }
        public static bool IsSubplotsHovered()
        {
            byte ret = ImPlotNative.ImPlot_IsSubplotsHovered();
            return ret != 0;
        }
        public static void ItemIcon(Vector4 col)
        {
            ImPlotNative.ImPlot_ItemIcon_Vec4(col);
        }
        public static void ItemIcon(uint col)
        {
            ImPlotNative.ImPlot_ItemIcon_U32(col);
        }
        public static void MapInputDefault()
        {
            ImPlotInputMap* dst = null;
            ImPlotNative.ImPlot_MapInputDefault(dst);
        }
        public static void MapInputDefault(ImPlotInputMapPtr dst)
        {
            ImPlotInputMap* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_MapInputDefault(native_dst);
        }
        public static void MapInputReverse()
        {
            ImPlotInputMap* dst = null;
            ImPlotNative.ImPlot_MapInputReverse(dst);
        }
        public static void MapInputReverse(ImPlotInputMapPtr dst)
        {
            ImPlotInputMap* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_MapInputReverse(native_dst);
        }
        public static Vector4 NextColormapColor()
        {
            Vector4 __retval;
            ImPlotNative.ImPlot_NextColormapColor(&__retval);
            return __retval;
        }
        public static ImPlotPoint PixelsToPlot(Vector2 pix)
        {
            ImPlotPoint __retval;
            ImAxis x_axis = (ImAxis)(-1);
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_PixelsToPlot_Vec2(&__retval, pix, x_axis, y_axis);
            return __retval;
        }
        public static ImPlotPoint PixelsToPlot(Vector2 pix, ImAxis x_axis)
        {
            ImPlotPoint __retval;
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_PixelsToPlot_Vec2(&__retval, pix, x_axis, y_axis);
            return __retval;
        }
        public static ImPlotPoint PixelsToPlot(Vector2 pix, ImAxis x_axis, ImAxis y_axis)
        {
            ImPlotPoint __retval;
            ImPlotNative.ImPlot_PixelsToPlot_Vec2(&__retval, pix, x_axis, y_axis);
            return __retval;
        }
        public static ImPlotPoint PixelsToPlot(float x, float y)
        {
            ImPlotPoint __retval;
            ImAxis x_axis = (ImAxis)(-1);
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_PixelsToPlot_Float(&__retval, x, y, x_axis, y_axis);
            return __retval;
        }
        public static ImPlotPoint PixelsToPlot(float x, float y, ImAxis x_axis)
        {
            ImPlotPoint __retval;
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_PixelsToPlot_Float(&__retval, x, y, x_axis, y_axis);
            return __retval;
        }
        public static ImPlotPoint PixelsToPlot(float x, float y, ImAxis x_axis, ImAxis y_axis)
        {
            ImPlotPoint __retval;
            ImPlotNative.ImPlot_PixelsToPlot_Float(&__retval, x, y, x_axis, y_axis);
            return __retval;
        }
        public static void PlotBarGroups(string[] label_ids, ref float values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_FloatPtr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref float values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_FloatPtr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref float values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_FloatPtr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref float values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_FloatPtr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref double values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_doublePtr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref double values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_doublePtr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref double values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_doublePtr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref double values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_doublePtr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref sbyte values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S8Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref sbyte values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S8Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref sbyte values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S8Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref sbyte values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S8Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref byte values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U8Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref byte values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U8Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref byte values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U8Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref byte values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U8Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref short values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S16Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref short values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S16Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref short values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S16Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref short values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S16Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref ushort values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U16Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref ushort values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U16Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref ushort values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U16Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref ushort values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U16Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref int values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S32Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref int values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S32Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref int values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S32Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref int values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S32Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref uint values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U32Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref uint values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U32Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref uint values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U32Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref uint values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U32Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref long values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S64Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref long values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S64Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref long values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S64Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref long values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_S64Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref ulong values, int item_count, int group_count)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double group_size = 0.67;
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U64Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref ulong values, int item_count, int group_count, double group_size)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            double shift = 0;
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U64Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref ulong values, int item_count, int group_count, double group_size, double shift)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            ImPlotBarGroupsFlags flags = (ImPlotBarGroupsFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U64Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
        public static void PlotBarGroups(string[] label_ids, ref ulong values, int item_count, int group_count, double group_size, double shift, ImPlotBarGroupsFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarGroups_U64Ptr(native_label_ids, native_values, item_count, group_count, group_size, shift, flags);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref float values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref float values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref float values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref float values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref float values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref float values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref float values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref float values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref float values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref float values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_FloatPtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref double values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref double values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref double values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref double values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref double values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref double values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref double values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref double values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref double values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref double values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_doublePtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref sbyte values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref sbyte values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref sbyte values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref sbyte values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref sbyte values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref sbyte values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref sbyte values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref sbyte values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref sbyte values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref sbyte values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref byte values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref byte values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref byte values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref byte values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref byte values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref byte values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref byte values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref byte values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref byte values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref byte values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U8PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref short values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref short values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref short values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref short values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref short values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref short values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref short values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref short values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref short values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref short values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ushort values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ushort values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ushort values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ushort values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ushort values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ushort values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ushort values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ushort values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ushort values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ushort values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U16PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref int values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref int values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref int values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref int values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref int values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref int values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref int values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref int values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref int values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref int values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref uint values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref uint values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref uint values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref uint values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref uint values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref uint values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref uint values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref uint values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref uint values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref uint values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U32PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref long values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref long values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref long values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref long values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref long values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref long values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref long values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref long values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref long values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref long values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_S64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_size = 0.67;
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ulong values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ulong values, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ulong values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ulong values, int count, double bar_size, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ulong values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ulong values, int count, double bar_size, double shift, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ulong values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ulong values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ulong values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ulong values, int count, double bar_size, double shift, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBars_U64PtrInt(native_label_id, native_values, count, bar_size, shift, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref float xs, ref float ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref float xs, ref float ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref float xs, ref float ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref float xs, ref float ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref double xs, ref double ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref double xs, ref double ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref double xs, ref double ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref double xs, ref double ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref sbyte xs, ref sbyte ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref sbyte xs, ref sbyte ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref sbyte xs, ref sbyte ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref sbyte xs, ref sbyte ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref byte xs, ref byte ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref byte xs, ref byte ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref byte xs, ref byte ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref byte xs, ref byte ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref short xs, ref short ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref short xs, ref short ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref short xs, ref short ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref short xs, ref short ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ushort xs, ref ushort ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ushort xs, ref ushort ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ushort xs, ref ushort ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ushort xs, ref ushort ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref int xs, ref int ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref int xs, ref int ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref int xs, ref int ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref int xs, ref int ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref uint xs, ref uint ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref uint xs, ref uint ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref uint xs, ref uint ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref uint xs, ref uint ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref long xs, ref long ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref long xs, ref long ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref long xs, ref long ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref long xs, ref long ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ulong xs, ref ulong ys, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ulong xs, ref ulong ys, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ulong xs, ref ulong ys, int count, double bar_size, ImPlotBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBars(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotBars(string label_id, ref ulong xs, ref ulong ys, int count, double bar_size, ImPlotBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBars_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, bar_size, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBarsG(ReadOnlySpan<char> label_id, IntPtr getter, IntPtr data, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            ImPlotNative.ImPlot_PlotBarsG(native_label_id, getter, native_data, count, bar_size, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#endif
        public static void PlotBarsG(string label_id, IntPtr getter, IntPtr data, int count, double bar_size)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotBarsFlags flags = (ImPlotBarsFlags)0;
            ImPlotNative.ImPlot_PlotBarsG(native_label_id, getter, native_data, count, bar_size, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotBarsG(ReadOnlySpan<char> label_id, IntPtr getter, IntPtr data, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotNative.ImPlot_PlotBarsG(native_label_id, getter, native_data, count, bar_size, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#endif
        public static void PlotBarsG(string label_id, IntPtr getter, IntPtr data, int count, double bar_size, ImPlotBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotNative.ImPlot_PlotBarsG(native_label_id, getter, native_data, count, bar_size, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_FloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_FloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_FloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref float xs, ref float ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_FloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_FloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref float xs, ref float ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_FloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_FloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref float xs, ref float ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_FloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_doublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_doublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_doublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref double xs, ref double ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_doublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_doublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref double xs, ref double ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_doublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_doublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref double xs, ref double ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_doublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref byte xs, ref byte ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref byte xs, ref byte ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref byte xs, ref byte ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref short xs, ref short ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref short xs, ref short ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref short xs, ref short ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref int xs, ref int ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref int xs, ref int ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref int xs, ref int ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref uint xs, ref uint ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref uint xs, ref uint ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref uint xs, ref uint ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref long xs, ref long ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref long xs, ref long ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref long xs, ref long ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_S64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotDigitalFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigital(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotDigital(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotDigitalFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigital_U64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigitalG(ReadOnlySpan<char> label_id, IntPtr getter, IntPtr data, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            ImPlotNative.ImPlot_PlotDigitalG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#endif
        public static void PlotDigitalG(string label_id, IntPtr getter, IntPtr data, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotDigitalFlags flags = (ImPlotDigitalFlags)0;
            ImPlotNative.ImPlot_PlotDigitalG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDigitalG(ReadOnlySpan<char> label_id, IntPtr getter, IntPtr data, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotNative.ImPlot_PlotDigitalG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#endif
        public static void PlotDigitalG(string label_id, IntPtr getter, IntPtr data, int count, ImPlotDigitalFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotNative.ImPlot_PlotDigitalG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDummy(ReadOnlySpan<char> label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDummyFlags flags = (ImPlotDummyFlags)0;
            ImPlotNative.ImPlot_PlotDummy(native_label_id, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#endif
        public static void PlotDummy(string label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotDummyFlags flags = (ImPlotDummyFlags)0;
            ImPlotNative.ImPlot_PlotDummy(native_label_id, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotDummy(ReadOnlySpan<char> label_id, ImPlotDummyFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotNative.ImPlot_PlotDummy(native_label_id, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#endif
        public static void PlotDummy(string label_id, ImPlotDummyFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotNative.ImPlot_PlotDummy(native_label_id, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref float xs, ref float ys, ref float err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref float xs, ref float ys, ref float err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref float xs, ref float ys, ref float err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref float xs, ref float ys, ref float err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref double xs, ref double ys, ref double err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref double xs, ref double ys, ref double err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref double xs, ref double ys, ref double err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref double xs, ref double ys, ref double err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, ref byte err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, ref byte err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, ref byte err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, ref byte err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref short xs, ref short ys, ref short err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref short xs, ref short ys, ref short err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref short xs, ref short ys, ref short err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref short xs, ref short ys, ref short err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, ref ushort err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, ref ushort err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, ref ushort err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, ref ushort err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref int xs, ref int ys, ref int err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref int xs, ref int ys, ref int err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref int xs, ref int ys, ref int err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref int xs, ref int ys, ref int err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, ref uint err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, ref uint err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, ref uint err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, ref uint err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref long xs, ref long ys, ref long err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref long xs, ref long ys, ref long err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref long xs, ref long ys, ref long err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref long xs, ref long ys, ref long err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, ref ulong err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, ref ulong err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, ref ulong err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, ref ulong err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_FloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_doublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_S64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotErrorBarsFlags flags = (ImPlotErrorBarsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count, ImPlotErrorBarsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count, ImPlotErrorBarsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotErrorBars(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#endif
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count, ImPlotErrorBarsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBars_U64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, flags, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref float values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref float values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref float values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref float values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref float values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref float values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref float values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_FloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref double values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref double values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref double values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref double values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref double values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref double values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref double values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_doublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref sbyte values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref sbyte values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref byte values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref byte values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref byte values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref byte values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref byte values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref byte values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref byte values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref short values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref short values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref short values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref short values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref short values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref short values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref short values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref ushort values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref ushort values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref int values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref int values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref int values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref int values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref int values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref int values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref int values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref uint values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref uint values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref uint values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref long values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref long values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref long values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref long values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref long values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref long values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref long values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_S64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref ulong values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_min = 0;
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref ulong values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale_max = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotHeatmapFlags flags = (ImPlotHeatmapFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotHeatmap(ReadOnlySpan<char> label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, ReadOnlySpan<char> label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max, ImPlotHeatmapFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmap_U64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref float values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref float values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref float values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref float values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref float values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref float values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref float values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref float values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_FloatPtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref double values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref double values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref double values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref double values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref double values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref double values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref double values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref double values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_doublePtr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref sbyte values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref sbyte values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref sbyte values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref sbyte values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref sbyte values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref sbyte values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref sbyte values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref sbyte values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref byte values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref byte values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref byte values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref byte values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref byte values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref byte values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref byte values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref byte values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U8Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref short values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref short values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref short values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref short values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref short values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref short values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref short values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref short values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref ushort values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref ushort values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref ushort values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref ushort values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref ushort values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref ushort values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref ushort values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref ushort values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U16Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref int values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref int values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref int values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref int values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref int values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref int values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref int values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref int values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref uint values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref uint values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref uint values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref uint values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref uint values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref uint values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref uint values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref uint values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U32Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref long values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref long values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref long values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref long values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref long values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref long values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref long values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref long values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_S64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int bins = (int)ImPlotBin.Sturges;
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref ulong values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref ulong values, int count, int bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double bar_scale = 1.0;
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref ulong values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref ulong values, int count, int bins, double bar_scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRange range = new ImPlotRange();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref ulong values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref ulong values, int count, int bins, double bar_scale, ImPlotRange range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram(ReadOnlySpan<char> label_id, ref ulong values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#endif
        public static double PlotHistogram(string label_id, ref ulong values, int count, int bins, double bar_scale, ImPlotRange range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                double ret = ImPlotNative.ImPlot_PlotHistogram_U64Ptr(native_label_id, native_values, count, bins, bar_scale, range, flags);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                return ret;
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref float xs, ref float ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref float xs, ref float ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref float xs, ref float ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref float xs, ref float ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_FloatPtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref double xs, ref double ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref double xs, ref double ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref double xs, ref double ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref double xs, ref double ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_doublePtr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref sbyte xs, ref sbyte ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref sbyte xs, ref sbyte ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref sbyte xs, ref sbyte ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref sbyte xs, ref sbyte ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref byte xs, ref byte ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref byte xs, ref byte ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref byte xs, ref byte ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref byte xs, ref byte ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U8Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref short xs, ref short ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref short xs, ref short ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref short xs, ref short ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref short xs, ref short ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref ushort xs, ref ushort ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref ushort xs, ref ushort ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref ushort xs, ref ushort ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref ushort xs, ref ushort ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U16Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref int xs, ref int ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref int xs, ref int ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref int xs, ref int ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref int xs, ref int ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref uint xs, ref uint ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref uint xs, ref uint ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref uint xs, ref uint ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref uint xs, ref uint ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U32Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref long xs, ref long ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref long xs, ref long ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref long xs, ref long ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref long xs, ref long ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_S64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int x_bins = (int)ImPlotBin.Sturges;
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref ulong xs, ref ulong ys, int count, int x_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int y_bins = (int)ImPlotBin.Sturges;
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref ulong xs, ref ulong ys, int count, int x_bins, int y_bins)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotRect range = new ImPlotRect();
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref ulong xs, ref ulong ys, int count, int x_bins, int y_bins, ImPlotRect range)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotHistogramFlags flags = (ImPlotHistogramFlags)0;
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static double PlotHistogram2D(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#endif
        public static double PlotHistogram2D(string label_id, ref ulong xs, ref ulong ys, int count, int x_bins, int y_bins, ImPlotRect range, ImPlotHistogramFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    double ret = ImPlotNative.ImPlot_PlotHistogram2D_U64Ptr(native_label_id, native_xs, native_ys, count, x_bins, y_bins, range, flags);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                    return ret;
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotImage(ReadOnlySpan<char> label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            Vector2 uv0 = new Vector2();
            Vector2 uv1 = new Vector2(1, 1);
            Vector4 tint_col = new Vector4(1, 1, 1, 1);
            ImPlotImageFlags flags = (ImPlotImageFlags)0;
            ImPlotNative.ImPlot_PlotImage(native_label_id, user_texture_id, bounds_min, bounds_max, uv0, uv1, tint_col, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#endif
        public static void PlotImage(string label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            Vector2 uv0 = new Vector2();
            Vector2 uv1 = new Vector2(1, 1);
            Vector4 tint_col = new Vector4(1, 1, 1, 1);
            ImPlotImageFlags flags = (ImPlotImageFlags)0;
            ImPlotNative.ImPlot_PlotImage(native_label_id, user_texture_id, bounds_min, bounds_max, uv0, uv1, tint_col, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotImage(ReadOnlySpan<char> label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            Vector2 uv1 = new Vector2(1, 1);
            Vector4 tint_col = new Vector4(1, 1, 1, 1);
            ImPlotImageFlags flags = (ImPlotImageFlags)0;
            ImPlotNative.ImPlot_PlotImage(native_label_id, user_texture_id, bounds_min, bounds_max, uv0, uv1, tint_col, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#endif
        public static void PlotImage(string label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            Vector2 uv1 = new Vector2(1, 1);
            Vector4 tint_col = new Vector4(1, 1, 1, 1);
            ImPlotImageFlags flags = (ImPlotImageFlags)0;
            ImPlotNative.ImPlot_PlotImage(native_label_id, user_texture_id, bounds_min, bounds_max, uv0, uv1, tint_col, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotImage(ReadOnlySpan<char> label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0, Vector2 uv1)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            Vector4 tint_col = new Vector4(1, 1, 1, 1);
            ImPlotImageFlags flags = (ImPlotImageFlags)0;
            ImPlotNative.ImPlot_PlotImage(native_label_id, user_texture_id, bounds_min, bounds_max, uv0, uv1, tint_col, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#endif
        public static void PlotImage(string label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0, Vector2 uv1)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            Vector4 tint_col = new Vector4(1, 1, 1, 1);
            ImPlotImageFlags flags = (ImPlotImageFlags)0;
            ImPlotNative.ImPlot_PlotImage(native_label_id, user_texture_id, bounds_min, bounds_max, uv0, uv1, tint_col, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotImage(ReadOnlySpan<char> label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0, Vector2 uv1, Vector4 tint_col)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotImageFlags flags = (ImPlotImageFlags)0;
            ImPlotNative.ImPlot_PlotImage(native_label_id, user_texture_id, bounds_min, bounds_max, uv0, uv1, tint_col, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#endif
        public static void PlotImage(string label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0, Vector2 uv1, Vector4 tint_col)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotImageFlags flags = (ImPlotImageFlags)0;
            ImPlotNative.ImPlot_PlotImage(native_label_id, user_texture_id, bounds_min, bounds_max, uv0, uv1, tint_col, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotImage(ReadOnlySpan<char> label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0, Vector2 uv1, Vector4 tint_col, ImPlotImageFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotNative.ImPlot_PlotImage(native_label_id, user_texture_id, bounds_min, bounds_max, uv0, uv1, tint_col, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#endif
        public static void PlotImage(string label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0, Vector2 uv1, Vector4 tint_col, ImPlotImageFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotNative.ImPlot_PlotImage(native_label_id, user_texture_id, bounds_min, bounds_max, uv0, uv1, tint_col, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_FloatPtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_FloatPtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref float values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_FloatPtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref float values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_FloatPtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref float values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_FloatPtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref float values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_FloatPtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref float values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_FloatPtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref float values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_FloatPtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_doublePtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_doublePtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref double values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_doublePtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref double values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_doublePtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref double values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_doublePtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref double values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_doublePtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref double values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_doublePtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref double values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_doublePtr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref sbyte values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref sbyte values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref sbyte values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref sbyte values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref sbyte values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref sbyte values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref byte values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref byte values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref byte values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref byte values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref byte values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref byte values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U8Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref short values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref short values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref short values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref short values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref short values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref short values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref ushort values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref ushort values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref ushort values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref ushort values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref ushort values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref ushort values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U16Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref int values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref int values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref int values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref int values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref int values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref int values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref uint values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref uint values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref uint values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref uint values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref uint values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref uint values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U32Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref long values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref long values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref long values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref long values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref long values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref long values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_S64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotInfLinesFlags flags = (ImPlotInfLinesFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref ulong values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref ulong values, int count, ImPlotInfLinesFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref ulong values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref ulong values, int count, ImPlotInfLinesFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotInfLines(ReadOnlySpan<char> label_id, ref ulong values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotInfLines(string label_id, ref ulong values, int count, ImPlotInfLinesFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotInfLines_U64Ptr(native_label_id, native_values, count, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref float values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref float values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref float values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref float values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref float values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref float values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref float values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref float values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref float values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref float values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref double values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref double values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref double values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref double values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref double values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref double values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref double values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref double values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref double values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref double values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref sbyte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref sbyte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref sbyte values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref sbyte values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref byte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref byte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref byte values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref byte values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref byte values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref byte values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref byte values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref byte values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref byte values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref byte values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref short values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref short values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref short values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref short values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref short values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref short values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref short values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref short values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref short values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref short values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ushort values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ushort values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ushort values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ushort values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ushort values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ushort values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ushort values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ushort values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ushort values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ushort values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref int values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref int values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref int values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref int values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref int values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref int values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref int values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref int values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref int values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref int values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref uint values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref uint values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref uint values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref uint values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref uint values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref uint values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref uint values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref uint values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref uint values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref uint values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref long values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref long values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref long values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref long values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref long values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref long values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref long values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref long values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref long values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref long values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ulong values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ulong values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ulong values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ulong values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ulong values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ulong values, int count, double xscale, double xstart, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ulong values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ulong values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ulong values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ulong values, int count, double xscale, double xstart, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLine_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref float xs, ref float ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref float xs, ref float ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref float xs, ref float ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref double xs, ref double ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref double xs, ref double ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref double xs, ref double ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref byte xs, ref byte ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref byte xs, ref byte ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref byte xs, ref byte ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref short xs, ref short ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref short xs, ref short ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref short xs, ref short ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref int xs, ref int ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref int xs, ref int ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref int xs, ref int ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref uint xs, ref uint ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref uint xs, ref uint ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref uint xs, ref uint ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref long xs, ref long ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref long xs, ref long ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref long xs, ref long ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotLineFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLine(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotLine(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotLineFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLine_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLineG(ReadOnlySpan<char> label_id, IntPtr getter, IntPtr data, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            ImPlotNative.ImPlot_PlotLineG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#endif
        public static void PlotLineG(string label_id, IntPtr getter, IntPtr data, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotLineFlags flags = (ImPlotLineFlags)0;
            ImPlotNative.ImPlot_PlotLineG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotLineG(ReadOnlySpan<char> label_id, IntPtr getter, IntPtr data, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotNative.ImPlot_PlotLineG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#endif
        public static void PlotLineG(string label_id, IntPtr getter, IntPtr data, int count, ImPlotLineFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotNative.ImPlot_PlotLineG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_FloatPtr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_FloatPtr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_FloatPtr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_FloatPtr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_FloatPtr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_FloatPtr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_FloatPtr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_doublePtr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_doublePtr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_doublePtr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_doublePtr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_doublePtr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_doublePtr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_doublePtr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S8Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S8Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S8Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S8Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S8Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S8Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S8Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U8Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U8Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U8Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U8Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U8Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U8Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U8Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S16Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S16Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S16Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S16Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S16Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S16Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S16Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U16Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U16Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U16Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U16Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U16Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U16Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U16Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S32Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S32Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S32Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S32Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S32Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S32Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S32Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U32Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U32Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U32Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U32Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U32Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U32Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U32Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S64Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S64Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S64Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S64Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S64Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S64Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_S64Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U64Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U64Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U64Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U64Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPieChartFlags flags = (ImPlotPieChartFlags)0;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U64Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, ReadOnlySpan<char> label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U64Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#endif
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, string label_fmt, double angle0, ImPlotPieChartFlags flags)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                offset += Util.GetUtf8(s, native_label_ids_data + offset, label_ids_byteCounts[i]);
                native_label_ids_data[offset++] = 0;
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChart_U64Ptr(native_label_ids, native_values, count, x, y, radius, native_label_fmt, angle0, flags);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref float values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref float values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref float values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref float values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref float values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref float values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref float values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref float values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref float values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref float values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref double values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref double values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref double values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref double values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref double values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref double values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref double values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref double values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref double values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref double values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref sbyte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref sbyte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref sbyte values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref sbyte values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref byte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref byte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref byte values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref byte values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref byte values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref byte values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref byte values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref byte values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref byte values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref byte values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref short values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref short values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref short values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref short values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref short values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref short values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref short values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref short values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref short values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref short values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ushort values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ushort values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ushort values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ushort values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ushort values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ushort values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ushort values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ushort values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ushort values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ushort values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref int values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref int values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref int values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref int values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref int values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref int values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref int values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref int values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref int values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref int values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref uint values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref uint values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref uint values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref uint values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref uint values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref uint values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref uint values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref uint values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref uint values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref uint values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref long values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref long values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref long values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref long values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref long values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref long values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref long values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref long values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref long values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref long values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ulong values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ulong values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ulong values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ulong values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ulong values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ulong values, int count, double xscale, double xstart, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ulong values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ulong values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ulong values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ulong values, int count, double xscale, double xstart, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatter_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref float xs, ref float ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref float xs, ref float ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref float xs, ref float ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref double xs, ref double ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref double xs, ref double ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref double xs, ref double ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref byte xs, ref byte ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref byte xs, ref byte ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref byte xs, ref byte ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref short xs, ref short ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref short xs, ref short ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref short xs, ref short ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref int xs, ref int ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref int xs, ref int ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref int xs, ref int ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref uint xs, ref uint ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref uint xs, ref uint ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref uint xs, ref uint ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref long xs, ref long ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref long xs, ref long ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref long xs, ref long ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotScatterFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatter(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotScatter(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotScatterFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatter_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatterG(ReadOnlySpan<char> label_id, IntPtr getter, IntPtr data, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            ImPlotNative.ImPlot_PlotScatterG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#endif
        public static void PlotScatterG(string label_id, IntPtr getter, IntPtr data, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotScatterFlags flags = (ImPlotScatterFlags)0;
            ImPlotNative.ImPlot_PlotScatterG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotScatterG(ReadOnlySpan<char> label_id, IntPtr getter, IntPtr data, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotNative.ImPlot_PlotScatterG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#endif
        public static void PlotScatterG(string label_id, IntPtr getter, IntPtr data, int count, ImPlotScatterFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotNative.ImPlot_PlotScatterG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref float values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref float values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref float values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref float values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref float values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref float values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref float values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref float values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref float values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref float values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref float values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref float values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_FloatPtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref double values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref double values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref double values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref double values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref double values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref double values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref double values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref double values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref double values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref double values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref double values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref double values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_doublePtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref sbyte values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref sbyte values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref sbyte values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref sbyte values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref sbyte values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref sbyte values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref sbyte values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref sbyte values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref sbyte values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref sbyte values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref sbyte values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref sbyte values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref byte values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref byte values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref byte values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref byte values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref byte values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref byte values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref byte values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref byte values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref byte values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref byte values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref byte values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref byte values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U8PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref short values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref short values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref short values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref short values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref short values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref short values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref short values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref short values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref short values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref short values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref short values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref short values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ushort values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ushort values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ushort values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ushort values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ushort values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ushort values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ushort values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ushort values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ushort values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ushort values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ushort values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ushort values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U16PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref int values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref int values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref int values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref int values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref int values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref int values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref int values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref int values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref int values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref int values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref int values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref int values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref uint values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref uint values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref uint values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref uint values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref uint values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref uint values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref uint values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref uint values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref uint values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref uint values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref uint values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref uint values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U32PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref long values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref long values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref long values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref long values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref long values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref long values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref long values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref long values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref long values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref long values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref long values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref long values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_S64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ulong values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ulong values, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ulong values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ulong values, int count, double yref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ulong values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ulong values, int count, double yref, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ulong values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ulong values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ulong values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ulong values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ulong values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ulong values, int count, double yref, double xscale, double xstart, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShaded_U64PtrInt(native_label_id, native_values, count, yref, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref float xs, ref float ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref float xs, ref float ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref float xs, ref float ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref float xs, ref float ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref double xs, ref double ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref double xs, ref double ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref double xs, ref double ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref double xs, ref double ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref short xs, ref short ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref short xs, ref short ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref short xs, ref short ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref short xs, ref short ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref int xs, ref int ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref int xs, ref int ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref int xs, ref int ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref int xs, ref int ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref long xs, ref long ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref long xs, ref long ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref long xs, ref long ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref long xs, ref long ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double yref = 0;
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys, int count, double yref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys, int count, double yref, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys, int count, double yref, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys, int count, double yref, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, yref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref float xs, ref float ys1, ref float ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys1 = &ys1)
                {
                    fixed (float* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref float xs, ref float ys1, ref float ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys1 = &ys1)
                {
                    fixed (float* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref float xs, ref float ys1, ref float ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys1 = &ys1)
                {
                    fixed (float* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref float xs, ref float ys1, ref float ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys1 = &ys1)
                {
                    fixed (float* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref float xs, ref float ys1, ref float ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys1 = &ys1)
                {
                    fixed (float* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref float xs, ref float ys1, ref float ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys1 = &ys1)
                {
                    fixed (float* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref float xs, ref float ys1, ref float ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys1 = &ys1)
                {
                    fixed (float* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref float xs, ref float ys1, ref float ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys1 = &ys1)
                {
                    fixed (float* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_FloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref double xs, ref double ys1, ref double ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys1 = &ys1)
                {
                    fixed (double* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref double xs, ref double ys1, ref double ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys1 = &ys1)
                {
                    fixed (double* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref double xs, ref double ys1, ref double ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys1 = &ys1)
                {
                    fixed (double* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref double xs, ref double ys1, ref double ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys1 = &ys1)
                {
                    fixed (double* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref double xs, ref double ys1, ref double ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys1 = &ys1)
                {
                    fixed (double* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref double xs, ref double ys1, ref double ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys1 = &ys1)
                {
                    fixed (double* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref double xs, ref double ys1, ref double ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys1 = &ys1)
                {
                    fixed (double* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref double xs, ref double ys1, ref double ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys1 = &ys1)
                {
                    fixed (double* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_doublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys1, ref sbyte ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys1 = &ys1)
                {
                    fixed (sbyte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys1, ref sbyte ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys1 = &ys1)
                {
                    fixed (sbyte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys1, ref sbyte ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys1 = &ys1)
                {
                    fixed (sbyte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys1, ref sbyte ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys1 = &ys1)
                {
                    fixed (sbyte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys1, ref sbyte ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys1 = &ys1)
                {
                    fixed (sbyte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys1, ref sbyte ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys1 = &ys1)
                {
                    fixed (sbyte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys1, ref sbyte ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys1 = &ys1)
                {
                    fixed (sbyte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys1, ref sbyte ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys1 = &ys1)
                {
                    fixed (sbyte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys1, ref byte ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys1 = &ys1)
                {
                    fixed (byte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys1, ref byte ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys1 = &ys1)
                {
                    fixed (byte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys1, ref byte ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys1 = &ys1)
                {
                    fixed (byte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys1, ref byte ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys1 = &ys1)
                {
                    fixed (byte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys1, ref byte ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys1 = &ys1)
                {
                    fixed (byte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys1, ref byte ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys1 = &ys1)
                {
                    fixed (byte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys1, ref byte ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys1 = &ys1)
                {
                    fixed (byte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys1, ref byte ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys1 = &ys1)
                {
                    fixed (byte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref short xs, ref short ys1, ref short ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys1 = &ys1)
                {
                    fixed (short* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref short xs, ref short ys1, ref short ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys1 = &ys1)
                {
                    fixed (short* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref short xs, ref short ys1, ref short ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys1 = &ys1)
                {
                    fixed (short* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref short xs, ref short ys1, ref short ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys1 = &ys1)
                {
                    fixed (short* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref short xs, ref short ys1, ref short ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys1 = &ys1)
                {
                    fixed (short* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref short xs, ref short ys1, ref short ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys1 = &ys1)
                {
                    fixed (short* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref short xs, ref short ys1, ref short ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys1 = &ys1)
                {
                    fixed (short* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref short xs, ref short ys1, ref short ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys1 = &ys1)
                {
                    fixed (short* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys1, ref ushort ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys1 = &ys1)
                {
                    fixed (ushort* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys1, ref ushort ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys1 = &ys1)
                {
                    fixed (ushort* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys1, ref ushort ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys1 = &ys1)
                {
                    fixed (ushort* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys1, ref ushort ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys1 = &ys1)
                {
                    fixed (ushort* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys1, ref ushort ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys1 = &ys1)
                {
                    fixed (ushort* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys1, ref ushort ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys1 = &ys1)
                {
                    fixed (ushort* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys1, ref ushort ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys1 = &ys1)
                {
                    fixed (ushort* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys1, ref ushort ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys1 = &ys1)
                {
                    fixed (ushort* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref int xs, ref int ys1, ref int ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys1 = &ys1)
                {
                    fixed (int* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref int xs, ref int ys1, ref int ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys1 = &ys1)
                {
                    fixed (int* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref int xs, ref int ys1, ref int ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys1 = &ys1)
                {
                    fixed (int* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref int xs, ref int ys1, ref int ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys1 = &ys1)
                {
                    fixed (int* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref int xs, ref int ys1, ref int ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys1 = &ys1)
                {
                    fixed (int* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref int xs, ref int ys1, ref int ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys1 = &ys1)
                {
                    fixed (int* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref int xs, ref int ys1, ref int ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys1 = &ys1)
                {
                    fixed (int* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref int xs, ref int ys1, ref int ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys1 = &ys1)
                {
                    fixed (int* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys1, ref uint ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys1 = &ys1)
                {
                    fixed (uint* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys1, ref uint ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys1 = &ys1)
                {
                    fixed (uint* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys1, ref uint ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys1 = &ys1)
                {
                    fixed (uint* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys1, ref uint ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys1 = &ys1)
                {
                    fixed (uint* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys1, ref uint ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys1 = &ys1)
                {
                    fixed (uint* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys1, ref uint ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys1 = &ys1)
                {
                    fixed (uint* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys1, ref uint ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys1 = &ys1)
                {
                    fixed (uint* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys1, ref uint ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys1 = &ys1)
                {
                    fixed (uint* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref long xs, ref long ys1, ref long ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys1 = &ys1)
                {
                    fixed (long* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref long xs, ref long ys1, ref long ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys1 = &ys1)
                {
                    fixed (long* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref long xs, ref long ys1, ref long ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys1 = &ys1)
                {
                    fixed (long* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref long xs, ref long ys1, ref long ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys1 = &ys1)
                {
                    fixed (long* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref long xs, ref long ys1, ref long ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys1 = &ys1)
                {
                    fixed (long* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref long xs, ref long ys1, ref long ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys1 = &ys1)
                {
                    fixed (long* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref long xs, ref long ys1, ref long ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys1 = &ys1)
                {
                    fixed (long* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref long xs, ref long ys1, ref long ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys1 = &ys1)
                {
                    fixed (long* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_S64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys1, ref ulong ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys1 = &ys1)
                {
                    fixed (ulong* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys1, ref ulong ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys1 = &ys1)
                {
                    fixed (ulong* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys1, ref ulong ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys1 = &ys1)
                {
                    fixed (ulong* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys1, ref ulong ys2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys1 = &ys1)
                {
                    fixed (ulong* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys1, ref ulong ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys1 = &ys1)
                {
                    fixed (ulong* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys1, ref ulong ys2, int count, ImPlotShadedFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys1 = &ys1)
                {
                    fixed (ulong* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShaded(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys1, ref ulong ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys1 = &ys1)
                {
                    fixed (ulong* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#endif
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys1, ref ulong ys2, int count, ImPlotShadedFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys1 = &ys1)
                {
                    fixed (ulong* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShaded_U64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, flags, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShadedG(ReadOnlySpan<char> label_id, IntPtr getter1, IntPtr data1, IntPtr getter2, IntPtr data2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data1 = (void*)data1.ToPointer();
            void* native_data2 = (void*)data2.ToPointer();
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            ImPlotNative.ImPlot_PlotShadedG(native_label_id, getter1, native_data1, getter2, native_data2, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#endif
        public static void PlotShadedG(string label_id, IntPtr getter1, IntPtr data1, IntPtr getter2, IntPtr data2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data1 = (void*)data1.ToPointer();
            void* native_data2 = (void*)data2.ToPointer();
            ImPlotShadedFlags flags = (ImPlotShadedFlags)0;
            ImPlotNative.ImPlot_PlotShadedG(native_label_id, getter1, native_data1, getter2, native_data2, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotShadedG(ReadOnlySpan<char> label_id, IntPtr getter1, IntPtr data1, IntPtr getter2, IntPtr data2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data1 = (void*)data1.ToPointer();
            void* native_data2 = (void*)data2.ToPointer();
            ImPlotNative.ImPlot_PlotShadedG(native_label_id, getter1, native_data1, getter2, native_data2, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#endif
        public static void PlotShadedG(string label_id, IntPtr getter1, IntPtr data1, IntPtr getter2, IntPtr data2, int count, ImPlotShadedFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data1 = (void*)data1.ToPointer();
            void* native_data2 = (void*)data2.ToPointer();
            ImPlotNative.ImPlot_PlotShadedG(native_label_id, getter1, native_data1, getter2, native_data2, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref float values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref float values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref float values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref float values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref float values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref float values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref float values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref float values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref float values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref float values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_FloatPtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref double values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref double values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref double values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref double values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref double values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref double values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref double values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref double values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref double values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref double values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_doublePtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref sbyte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref sbyte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref sbyte values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref sbyte values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref sbyte values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref byte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref byte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref byte values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref byte values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref byte values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref byte values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref byte values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref byte values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref byte values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref byte values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U8PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref short values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref short values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref short values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref short values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref short values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref short values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref short values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref short values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref short values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref short values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ushort values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ushort values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ushort values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ushort values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ushort values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ushort values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ushort values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ushort values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ushort values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ushort values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U16PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref int values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref int values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref int values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref int values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref int values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref int values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref int values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref int values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref int values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref int values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref uint values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref uint values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref uint values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref uint values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref uint values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref uint values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref uint values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref uint values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref uint values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref uint values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U32PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref long values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref long values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref long values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref long values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref long values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref long values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref long values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref long values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref long values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref long values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_S64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ulong values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ulong values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xstart = 0;
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ulong values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ulong values, int count, double xscale, double xstart)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ulong values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ulong values, int count, double xscale, double xstart, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ulong values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ulong values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ulong values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ulong values, int count, double xscale, double xstart, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairs_U64PtrInt(native_label_id, native_values, count, xscale, xstart, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref float xs, ref float ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref float xs, ref float ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref float xs, ref float ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref double xs, ref double ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref double xs, ref double ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref double xs, ref double ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref sbyte xs, ref sbyte ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref byte xs, ref byte ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref byte xs, ref byte ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref byte xs, ref byte ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref short xs, ref short ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref short xs, ref short ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref short xs, ref short ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ushort xs, ref ushort ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref int xs, ref int ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref int xs, ref int ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref int xs, ref int ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref uint xs, ref uint ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref uint xs, ref uint ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref uint xs, ref uint ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref long xs, ref long ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref long xs, ref long ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref long xs, ref long ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotStairsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairs(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStairs(string label_id, ref ulong xs, ref ulong ys, int count, ImPlotStairsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairs_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairsG(ReadOnlySpan<char> label_id, IntPtr getter, IntPtr data, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            ImPlotNative.ImPlot_PlotStairsG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#endif
        public static void PlotStairsG(string label_id, IntPtr getter, IntPtr data, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotStairsFlags flags = (ImPlotStairsFlags)0;
            ImPlotNative.ImPlot_PlotStairsG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStairsG(ReadOnlySpan<char> label_id, IntPtr getter, IntPtr data, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotNative.ImPlot_PlotStairsG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#endif
        public static void PlotStairsG(string label_id, IntPtr getter, IntPtr data, int count, ImPlotStairsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            void* native_data = (void*)data.ToPointer();
            ImPlotNative.ImPlot_PlotStairsG(native_label_id, getter, native_data, count, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref float values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref float values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref float values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref float values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref float values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref float values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref float values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref float values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref float values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref float values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref float values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref float values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_FloatPtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref double values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref double values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref double values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref double values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref double values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref double values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref double values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref double values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref double values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref double values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref double values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref double values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_doublePtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref sbyte values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref sbyte values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref sbyte values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref sbyte values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref sbyte values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref sbyte values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref sbyte values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref sbyte values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref sbyte values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref sbyte values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref sbyte values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref sbyte values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref byte values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref byte values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref byte values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref byte values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref byte values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref byte values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref byte values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref byte values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref byte values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref byte values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref byte values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref byte values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U8PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref short values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref short values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref short values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref short values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref short values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref short values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref short values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref short values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref short values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref short values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref short values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref short values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ushort values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ushort values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ushort values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ushort values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ushort values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ushort values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ushort values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ushort values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ushort values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ushort values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ushort values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ushort values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U16PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref int values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref int values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref int values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref int values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref int values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref int values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref int values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref int values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref int values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref int values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref int values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref int values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref uint values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref uint values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref uint values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref uint values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref uint values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref uint values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref uint values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref uint values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref uint values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref uint values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref uint values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref uint values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U32PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref long values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref long values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref long values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref long values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref long values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref long values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref long values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref long values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref long values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref long values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref long values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref long values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_S64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ulong values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ulong values, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double scale = 1;
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ulong values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ulong values, int count, double @ref, double scale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double start = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ulong values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ulong values, int count, double @ref, double scale, double start)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ulong values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ulong values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ulong values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ulong values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ulong values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ulong values, int count, double @ref, double scale, double start, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStems_U64PtrInt(native_label_id, native_values, count, @ref, scale, start, flags, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref float xs, ref float ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref float xs, ref float ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref float xs, ref float ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref float xs, ref float ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref float xs, ref float ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_FloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref double xs, ref double ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref double xs, ref double ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref double xs, ref double ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref double xs, ref double ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref double xs, ref double ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_doublePtrdoublePtr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref sbyte xs, ref sbyte ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref sbyte xs, ref sbyte ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref sbyte xs, ref sbyte ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref sbyte xs, ref sbyte ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref sbyte xs, ref sbyte ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S8PtrS8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref byte xs, ref byte ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref byte xs, ref byte ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref byte xs, ref byte ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref byte xs, ref byte ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref byte xs, ref byte ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U8PtrU8Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref short xs, ref short ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref short xs, ref short ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref short xs, ref short ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref short xs, ref short ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref short xs, ref short ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S16PtrS16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ushort xs, ref ushort ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ushort xs, ref ushort ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ushort xs, ref ushort ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ushort xs, ref ushort ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ushort xs, ref ushort ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U16PtrU16Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref int xs, ref int ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref int xs, ref int ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref int xs, ref int ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref int xs, ref int ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref int xs, ref int ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S32PtrS32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref uint xs, ref uint ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref uint xs, ref uint ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref uint xs, ref uint ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref uint xs, ref uint ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref uint xs, ref uint ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U32PtrU32Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref long xs, ref long ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref long xs, ref long ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref long xs, ref long ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref long xs, ref long ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref long xs, ref long ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_S64PtrS64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double @ref = 0;
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ulong xs, ref ulong ys, int count, double @ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotStemsFlags flags = (ImPlotStemsFlags)0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ulong xs, ref ulong ys, int count, double @ref, ImPlotStemsFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ulong xs, ref ulong ys, int count, double @ref, ImPlotStemsFlags flags, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotStems(ReadOnlySpan<char> label_id, ref ulong xs, ref ulong ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#endif
        public static void PlotStems(string label_id, ref ulong xs, ref ulong ys, int count, double @ref, ImPlotStemsFlags flags, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStems_U64PtrU64Ptr(native_label_id, native_xs, native_ys, count, @ref, flags, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotText(ReadOnlySpan<char> text, double x, double y)
        {
            byte* native_text;
            int text_byteCount = 0;
            if (text != null)
            {
                text_byteCount = Encoding.UTF8.GetByteCount(text);
                if (text_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_text = Util.Allocate(text_byteCount + 1);
                }
                else
                {
                    byte* native_text_stackBytes = stackalloc byte[text_byteCount + 1];
                    native_text = native_text_stackBytes;
                }
                int native_text_offset = Util.GetUtf8(text, native_text, text_byteCount);
                native_text[native_text_offset] = 0;
            }
            else { native_text = null; }
            Vector2 pix_offset = new Vector2();
            ImPlotTextFlags flags = (ImPlotTextFlags)0;
            ImPlotNative.ImPlot_PlotText(native_text, x, y, pix_offset, flags);
            if (text_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_text);
            }
        }
#endif
        public static void PlotText(string text, double x, double y)
        {
            byte* native_text;
            int text_byteCount = 0;
            if (text != null)
            {
                text_byteCount = Encoding.UTF8.GetByteCount(text);
                if (text_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_text = Util.Allocate(text_byteCount + 1);
                }
                else
                {
                    byte* native_text_stackBytes = stackalloc byte[text_byteCount + 1];
                    native_text = native_text_stackBytes;
                }
                int native_text_offset = Util.GetUtf8(text, native_text, text_byteCount);
                native_text[native_text_offset] = 0;
            }
            else { native_text = null; }
            Vector2 pix_offset = new Vector2();
            ImPlotTextFlags flags = (ImPlotTextFlags)0;
            ImPlotNative.ImPlot_PlotText(native_text, x, y, pix_offset, flags);
            if (text_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_text);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotText(ReadOnlySpan<char> text, double x, double y, Vector2 pix_offset)
        {
            byte* native_text;
            int text_byteCount = 0;
            if (text != null)
            {
                text_byteCount = Encoding.UTF8.GetByteCount(text);
                if (text_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_text = Util.Allocate(text_byteCount + 1);
                }
                else
                {
                    byte* native_text_stackBytes = stackalloc byte[text_byteCount + 1];
                    native_text = native_text_stackBytes;
                }
                int native_text_offset = Util.GetUtf8(text, native_text, text_byteCount);
                native_text[native_text_offset] = 0;
            }
            else { native_text = null; }
            ImPlotTextFlags flags = (ImPlotTextFlags)0;
            ImPlotNative.ImPlot_PlotText(native_text, x, y, pix_offset, flags);
            if (text_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_text);
            }
        }
#endif
        public static void PlotText(string text, double x, double y, Vector2 pix_offset)
        {
            byte* native_text;
            int text_byteCount = 0;
            if (text != null)
            {
                text_byteCount = Encoding.UTF8.GetByteCount(text);
                if (text_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_text = Util.Allocate(text_byteCount + 1);
                }
                else
                {
                    byte* native_text_stackBytes = stackalloc byte[text_byteCount + 1];
                    native_text = native_text_stackBytes;
                }
                int native_text_offset = Util.GetUtf8(text, native_text, text_byteCount);
                native_text[native_text_offset] = 0;
            }
            else { native_text = null; }
            ImPlotTextFlags flags = (ImPlotTextFlags)0;
            ImPlotNative.ImPlot_PlotText(native_text, x, y, pix_offset, flags);
            if (text_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_text);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PlotText(ReadOnlySpan<char> text, double x, double y, Vector2 pix_offset, ImPlotTextFlags flags)
        {
            byte* native_text;
            int text_byteCount = 0;
            if (text != null)
            {
                text_byteCount = Encoding.UTF8.GetByteCount(text);
                if (text_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_text = Util.Allocate(text_byteCount + 1);
                }
                else
                {
                    byte* native_text_stackBytes = stackalloc byte[text_byteCount + 1];
                    native_text = native_text_stackBytes;
                }
                int native_text_offset = Util.GetUtf8(text, native_text, text_byteCount);
                native_text[native_text_offset] = 0;
            }
            else { native_text = null; }
            ImPlotNative.ImPlot_PlotText(native_text, x, y, pix_offset, flags);
            if (text_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_text);
            }
        }
#endif
        public static void PlotText(string text, double x, double y, Vector2 pix_offset, ImPlotTextFlags flags)
        {
            byte* native_text;
            int text_byteCount = 0;
            if (text != null)
            {
                text_byteCount = Encoding.UTF8.GetByteCount(text);
                if (text_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_text = Util.Allocate(text_byteCount + 1);
                }
                else
                {
                    byte* native_text_stackBytes = stackalloc byte[text_byteCount + 1];
                    native_text = native_text_stackBytes;
                }
                int native_text_offset = Util.GetUtf8(text, native_text, text_byteCount);
                native_text[native_text_offset] = 0;
            }
            else { native_text = null; }
            ImPlotNative.ImPlot_PlotText(native_text, x, y, pix_offset, flags);
            if (text_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_text);
            }
        }
        public static Vector2 PlotToPixels(ImPlotPoint plt)
        {
            Vector2 __retval;
            ImAxis x_axis = (ImAxis)(-1);
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_PlotToPixels_PlotPoInt(&__retval, plt, x_axis, y_axis);
            return __retval;
        }
        public static Vector2 PlotToPixels(ImPlotPoint plt, ImAxis x_axis)
        {
            Vector2 __retval;
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_PlotToPixels_PlotPoInt(&__retval, plt, x_axis, y_axis);
            return __retval;
        }
        public static Vector2 PlotToPixels(ImPlotPoint plt, ImAxis x_axis, ImAxis y_axis)
        {
            Vector2 __retval;
            ImPlotNative.ImPlot_PlotToPixels_PlotPoInt(&__retval, plt, x_axis, y_axis);
            return __retval;
        }
        public static Vector2 PlotToPixels(double x, double y)
        {
            Vector2 __retval;
            ImAxis x_axis = (ImAxis)(-1);
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_PlotToPixels_double(&__retval, x, y, x_axis, y_axis);
            return __retval;
        }
        public static Vector2 PlotToPixels(double x, double y, ImAxis x_axis)
        {
            Vector2 __retval;
            ImAxis y_axis = (ImAxis)(-1);
            ImPlotNative.ImPlot_PlotToPixels_double(&__retval, x, y, x_axis, y_axis);
            return __retval;
        }
        public static Vector2 PlotToPixels(double x, double y, ImAxis x_axis, ImAxis y_axis)
        {
            Vector2 __retval;
            ImPlotNative.ImPlot_PlotToPixels_double(&__retval, x, y, x_axis, y_axis);
            return __retval;
        }
        public static void PopColormap()
        {
            int count = 1;
            ImPlotNative.ImPlot_PopColormap(count);
        }
        public static void PopColormap(int count)
        {
            ImPlotNative.ImPlot_PopColormap(count);
        }
        public static void PopPlotClipRect()
        {
            ImPlotNative.ImPlot_PopPlotClipRect();
        }
        public static void PopStyleColor()
        {
            int count = 1;
            ImPlotNative.ImPlot_PopStyleColor(count);
        }
        public static void PopStyleColor(int count)
        {
            ImPlotNative.ImPlot_PopStyleColor(count);
        }
        public static void PopStyleVar()
        {
            int count = 1;
            ImPlotNative.ImPlot_PopStyleVar(count);
        }
        public static void PopStyleVar(int count)
        {
            ImPlotNative.ImPlot_PopStyleVar(count);
        }
        public static void PushColormap(ImPlotColormap cmap)
        {
            ImPlotNative.ImPlot_PushColormap_PlotColormap(cmap);
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void PushColormap(ReadOnlySpan<char> name)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            ImPlotNative.ImPlot_PushColormap_Str(native_name);
            if (name_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_name);
            }
        }
#endif
        public static void PushColormap(string name)
        {
            byte* native_name;
            int name_byteCount = 0;
            if (name != null)
            {
                name_byteCount = Encoding.UTF8.GetByteCount(name);
                if (name_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_name = Util.Allocate(name_byteCount + 1);
                }
                else
                {
                    byte* native_name_stackBytes = stackalloc byte[name_byteCount + 1];
                    native_name = native_name_stackBytes;
                }
                int native_name_offset = Util.GetUtf8(name, native_name, name_byteCount);
                native_name[native_name_offset] = 0;
            }
            else { native_name = null; }
            ImPlotNative.ImPlot_PushColormap_Str(native_name);
            if (name_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_name);
            }
        }
        public static void PushPlotClipRect()
        {
            float expand = 0;
            ImPlotNative.ImPlot_PushPlotClipRect(expand);
        }
        public static void PushPlotClipRect(float expand)
        {
            ImPlotNative.ImPlot_PushPlotClipRect(expand);
        }
        public static void PushStyleColor(ImPlotCol idx, uint col)
        {
            ImPlotNative.ImPlot_PushStyleColor_U32(idx, col);
        }
        public static void PushStyleColor(ImPlotCol idx, Vector4 col)
        {
            ImPlotNative.ImPlot_PushStyleColor_Vec4(idx, col);
        }
        public static void PushStyleVar(ImPlotStyleVar idx, float val)
        {
            ImPlotNative.ImPlot_PushStyleVar_Float(idx, val);
        }
        public static void PushStyleVar(ImPlotStyleVar idx, int val)
        {
            ImPlotNative.ImPlot_PushStyleVar_Int(idx, val);
        }
        public static void PushStyleVar(ImPlotStyleVar idx, Vector2 val)
        {
            ImPlotNative.ImPlot_PushStyleVar_Vec2(idx, val);
        }
        public static Vector4 SampleColormap(float t)
        {
            Vector4 __retval;
            ImPlotColormap cmap = (ImPlotColormap)(-1);
            ImPlotNative.ImPlot_SampleColormap(&__retval, t, cmap);
            return __retval;
        }
        public static Vector4 SampleColormap(float t, ImPlotColormap cmap)
        {
            Vector4 __retval;
            ImPlotNative.ImPlot_SampleColormap(&__retval, t, cmap);
            return __retval;
        }
        public static void SetAxes(ImAxis x_axis, ImAxis y_axis)
        {
            ImPlotNative.ImPlot_SetAxes(x_axis, y_axis);
        }
        public static void SetAxis(ImAxis axis)
        {
            ImPlotNative.ImPlot_SetAxis(axis);
        }
        public static void SetCurrentContext(IntPtr ctx)
        {
            ImPlotNative.ImPlot_SetCurrentContext(ctx);
        }
        public static void SetImGuiContext(IntPtr ctx)
        {
            ImPlotNative.ImPlot_SetImGuiContext(ctx);
        }
        public static void SetNextAxesLimits(double x_min, double x_max, double y_min, double y_max)
        {
            ImPlotCond cond = ImPlotCond.Once;
            ImPlotNative.ImPlot_SetNextAxesLimits(x_min, x_max, y_min, y_max, cond);
        }
        public static void SetNextAxesLimits(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond)
        {
            ImPlotNative.ImPlot_SetNextAxesLimits(x_min, x_max, y_min, y_max, cond);
        }
        public static void SetNextAxesToFit()
        {
            ImPlotNative.ImPlot_SetNextAxesToFit();
        }
        public static void SetNextAxisLimits(ImAxis axis, double v_min, double v_max)
        {
            ImPlotCond cond = ImPlotCond.Once;
            ImPlotNative.ImPlot_SetNextAxisLimits(axis, v_min, v_max, cond);
        }
        public static void SetNextAxisLimits(ImAxis axis, double v_min, double v_max, ImPlotCond cond)
        {
            ImPlotNative.ImPlot_SetNextAxisLimits(axis, v_min, v_max, cond);
        }
        public static void SetNextAxisLinks(ImAxis axis, ref double link_min, ref double link_max)
        {
            fixed (double* native_link_min = &link_min)
            {
                fixed (double* native_link_max = &link_max)
                {
                    ImPlotNative.ImPlot_SetNextAxisLinks(axis, native_link_min, native_link_max);
                }
            }
        }
        public static void SetNextAxisToFit(ImAxis axis)
        {
            ImPlotNative.ImPlot_SetNextAxisToFit(axis);
        }
        public static void SetNextErrorBarStyle()
        {
            Vector4 col = new Vector4(0, 0, 0, -1);
            float size = -1;
            float weight = -1;
            ImPlotNative.ImPlot_SetNextErrorBarStyle(col, size, weight);
        }
        public static void SetNextErrorBarStyle(Vector4 col)
        {
            float size = -1;
            float weight = -1;
            ImPlotNative.ImPlot_SetNextErrorBarStyle(col, size, weight);
        }
        public static void SetNextErrorBarStyle(Vector4 col, float size)
        {
            float weight = -1;
            ImPlotNative.ImPlot_SetNextErrorBarStyle(col, size, weight);
        }
        public static void SetNextErrorBarStyle(Vector4 col, float size, float weight)
        {
            ImPlotNative.ImPlot_SetNextErrorBarStyle(col, size, weight);
        }
        public static void SetNextFillStyle()
        {
            Vector4 col = new Vector4(0, 0, 0, -1);
            float alpha_mod = -1;
            ImPlotNative.ImPlot_SetNextFillStyle(col, alpha_mod);
        }
        public static void SetNextFillStyle(Vector4 col)
        {
            float alpha_mod = -1;
            ImPlotNative.ImPlot_SetNextFillStyle(col, alpha_mod);
        }
        public static void SetNextFillStyle(Vector4 col, float alpha_mod)
        {
            ImPlotNative.ImPlot_SetNextFillStyle(col, alpha_mod);
        }
        public static void SetNextLineStyle()
        {
            Vector4 col = new Vector4(0, 0, 0, -1);
            float weight = -1;
            ImPlotNative.ImPlot_SetNextLineStyle(col, weight);
        }
        public static void SetNextLineStyle(Vector4 col)
        {
            float weight = -1;
            ImPlotNative.ImPlot_SetNextLineStyle(col, weight);
        }
        public static void SetNextLineStyle(Vector4 col, float weight)
        {
            ImPlotNative.ImPlot_SetNextLineStyle(col, weight);
        }
        public static void SetNextMarkerStyle()
        {
            ImPlotMarker marker = (ImPlotMarker)(-1);
            float size = -1;
            Vector4 fill = new Vector4(0, 0, 0, -1);
            float weight = -1;
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker)
        {
            float size = -1;
            Vector4 fill = new Vector4(0, 0, 0, -1);
            float weight = -1;
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker, float size)
        {
            Vector4 fill = new Vector4(0, 0, 0, -1);
            float weight = -1;
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker, float size, Vector4 fill)
        {
            float weight = -1;
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker, float size, Vector4 fill, float weight)
        {
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker, float size, Vector4 fill, float weight, Vector4 outline)
        {
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void SetupAxes(ReadOnlySpan<char> x_label, ReadOnlySpan<char> y_label)
        {
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            ImPlotAxisFlags x_flags = (ImPlotAxisFlags)0;
            ImPlotAxisFlags y_flags = (ImPlotAxisFlags)0;
            ImPlotNative.ImPlot_SetupAxes(native_x_label, native_y_label, x_flags, y_flags);
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
        }
#endif
        public static void SetupAxes(string x_label, string y_label)
        {
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            ImPlotAxisFlags x_flags = (ImPlotAxisFlags)0;
            ImPlotAxisFlags y_flags = (ImPlotAxisFlags)0;
            ImPlotNative.ImPlot_SetupAxes(native_x_label, native_y_label, x_flags, y_flags);
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void SetupAxes(ReadOnlySpan<char> x_label, ReadOnlySpan<char> y_label, ImPlotAxisFlags x_flags)
        {
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            ImPlotAxisFlags y_flags = (ImPlotAxisFlags)0;
            ImPlotNative.ImPlot_SetupAxes(native_x_label, native_y_label, x_flags, y_flags);
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
        }
#endif
        public static void SetupAxes(string x_label, string y_label, ImPlotAxisFlags x_flags)
        {
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            ImPlotAxisFlags y_flags = (ImPlotAxisFlags)0;
            ImPlotNative.ImPlot_SetupAxes(native_x_label, native_y_label, x_flags, y_flags);
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void SetupAxes(ReadOnlySpan<char> x_label, ReadOnlySpan<char> y_label, ImPlotAxisFlags x_flags, ImPlotAxisFlags y_flags)
        {
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            ImPlotNative.ImPlot_SetupAxes(native_x_label, native_y_label, x_flags, y_flags);
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
        }
#endif
        public static void SetupAxes(string x_label, string y_label, ImPlotAxisFlags x_flags, ImPlotAxisFlags y_flags)
        {
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            ImPlotNative.ImPlot_SetupAxes(native_x_label, native_y_label, x_flags, y_flags);
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
        }
        public static void SetupAxesLimits(double x_min, double x_max, double y_min, double y_max)
        {
            ImPlotCond cond = ImPlotCond.Once;
            ImPlotNative.ImPlot_SetupAxesLimits(x_min, x_max, y_min, y_max, cond);
        }
        public static void SetupAxesLimits(double x_min, double x_max, double y_min, double y_max, ImPlotCond cond)
        {
            ImPlotNative.ImPlot_SetupAxesLimits(x_min, x_max, y_min, y_max, cond);
        }
        public static void SetupAxis(ImAxis axis)
        {
            byte* native_label = null;
            ImPlotAxisFlags flags = (ImPlotAxisFlags)0;
            ImPlotNative.ImPlot_SetupAxis(axis, native_label, flags);
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void SetupAxis(ImAxis axis, ReadOnlySpan<char> label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            ImPlotAxisFlags flags = (ImPlotAxisFlags)0;
            ImPlotNative.ImPlot_SetupAxis(axis, native_label, flags);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
        }
#endif
        public static void SetupAxis(ImAxis axis, string label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            ImPlotAxisFlags flags = (ImPlotAxisFlags)0;
            ImPlotNative.ImPlot_SetupAxis(axis, native_label, flags);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void SetupAxis(ImAxis axis, ReadOnlySpan<char> label, ImPlotAxisFlags flags)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            ImPlotNative.ImPlot_SetupAxis(axis, native_label, flags);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
        }
#endif
        public static void SetupAxis(ImAxis axis, string label, ImPlotAxisFlags flags)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            ImPlotNative.ImPlot_SetupAxis(axis, native_label, flags);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void SetupAxisFormat(ImAxis axis, ReadOnlySpan<char> fmt)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_SetupAxisFormat_Str(axis, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
#endif
        public static void SetupAxisFormat(ImAxis axis, string fmt)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_SetupAxisFormat_Str(axis, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static void SetupAxisFormat(ImAxis axis, IntPtr formatter)
        {
            void* data = null;
            ImPlotNative.ImPlot_SetupAxisFormat_PlotFormatter(axis, formatter, data);
        }
        public static void SetupAxisFormat(ImAxis axis, IntPtr formatter, IntPtr data)
        {
            void* native_data = (void*)data.ToPointer();
            ImPlotNative.ImPlot_SetupAxisFormat_PlotFormatter(axis, formatter, native_data);
        }
        public static void SetupAxisLimits(ImAxis axis, double v_min, double v_max)
        {
            ImPlotCond cond = ImPlotCond.Once;
            ImPlotNative.ImPlot_SetupAxisLimits(axis, v_min, v_max, cond);
        }
        public static void SetupAxisLimits(ImAxis axis, double v_min, double v_max, ImPlotCond cond)
        {
            ImPlotNative.ImPlot_SetupAxisLimits(axis, v_min, v_max, cond);
        }
        public static void SetupAxisLimitsConstraints(ImAxis axis, double v_min, double v_max)
        {
            ImPlotNative.ImPlot_SetupAxisLimitsConstraints(axis, v_min, v_max);
        }
        public static void SetupAxisLinks(ImAxis axis, ref double link_min, ref double link_max)
        {
            fixed (double* native_link_min = &link_min)
            {
                fixed (double* native_link_max = &link_max)
                {
                    ImPlotNative.ImPlot_SetupAxisLinks(axis, native_link_min, native_link_max);
                }
            }
        }
        public static void SetupAxisScale(ImAxis axis, ImPlotScale scale)
        {
            ImPlotNative.ImPlot_SetupAxisScale_PlotScale(axis, scale);
        }
        public static void SetupAxisScale(ImAxis axis, IntPtr forward, IntPtr inverse)
        {
            void* data = null;
            ImPlotNative.ImPlot_SetupAxisScale_PlotTransform(axis, forward, inverse, data);
        }
        public static void SetupAxisScale(ImAxis axis, IntPtr forward, IntPtr inverse, IntPtr data)
        {
            void* native_data = (void*)data.ToPointer();
            ImPlotNative.ImPlot_SetupAxisScale_PlotTransform(axis, forward, inverse, native_data);
        }
        public static void SetupAxisTicks(ImAxis axis, ref double values, int n_ticks)
        {
            byte** labels = null;
            byte keep_default = 0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetupAxisTicks_doublePtr(axis, native_values, n_ticks, labels, keep_default);
            }
        }
        public static void SetupAxisTicks(ImAxis axis, ref double values, int n_ticks, string[] labels)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                offset += Util.GetUtf8(s, native_labels_data + offset, labels_byteCounts[i]);
                native_labels_data[offset++] = 0;
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte keep_default = 0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetupAxisTicks_doublePtr(axis, native_values, n_ticks, native_labels, keep_default);
            }
        }
        public static void SetupAxisTicks(ImAxis axis, ref double values, int n_ticks, string[] labels, bool keep_default)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                offset += Util.GetUtf8(s, native_labels_data + offset, labels_byteCounts[i]);
                native_labels_data[offset++] = 0;
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte native_keep_default = keep_default ? (byte)1 : (byte)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetupAxisTicks_doublePtr(axis, native_values, n_ticks, native_labels, native_keep_default);
            }
        }
        public static void SetupAxisTicks(ImAxis axis, double v_min, double v_max, int n_ticks)
        {
            byte** labels = null;
            byte keep_default = 0;
            ImPlotNative.ImPlot_SetupAxisTicks_double(axis, v_min, v_max, n_ticks, labels, keep_default);
        }
        public static void SetupAxisTicks(ImAxis axis, double v_min, double v_max, int n_ticks, string[] labels)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                offset += Util.GetUtf8(s, native_labels_data + offset, labels_byteCounts[i]);
                native_labels_data[offset++] = 0;
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte keep_default = 0;
            ImPlotNative.ImPlot_SetupAxisTicks_double(axis, v_min, v_max, n_ticks, native_labels, keep_default);
        }
        public static void SetupAxisTicks(ImAxis axis, double v_min, double v_max, int n_ticks, string[] labels, bool keep_default)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                offset += Util.GetUtf8(s, native_labels_data + offset, labels_byteCounts[i]);
                native_labels_data[offset++] = 0;
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte native_keep_default = keep_default ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_SetupAxisTicks_double(axis, v_min, v_max, n_ticks, native_labels, native_keep_default);
        }
        public static void SetupAxisZoomConstraints(ImAxis axis, double z_min, double z_max)
        {
            ImPlotNative.ImPlot_SetupAxisZoomConstraints(axis, z_min, z_max);
        }
        public static void SetupFinish()
        {
            ImPlotNative.ImPlot_SetupFinish();
        }
        public static void SetupLegend(ImPlotLocation location)
        {
            ImPlotLegendFlags flags = (ImPlotLegendFlags)0;
            ImPlotNative.ImPlot_SetupLegend(location, flags);
        }
        public static void SetupLegend(ImPlotLocation location, ImPlotLegendFlags flags)
        {
            ImPlotNative.ImPlot_SetupLegend(location, flags);
        }
        public static void SetupMouseText(ImPlotLocation location)
        {
            ImPlotMouseTextFlags flags = (ImPlotMouseTextFlags)0;
            ImPlotNative.ImPlot_SetupMouseText(location, flags);
        }
        public static void SetupMouseText(ImPlotLocation location, ImPlotMouseTextFlags flags)
        {
            ImPlotNative.ImPlot_SetupMouseText(location, flags);
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool ShowColormapSelector(ReadOnlySpan<char> label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte ret = ImPlotNative.ImPlot_ShowColormapSelector(native_label);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
#endif
        public static bool ShowColormapSelector(string label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte ret = ImPlotNative.ImPlot_ShowColormapSelector(native_label);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
        public static void ShowDemoWindow()
        {
            byte* p_open = null;
            ImPlotNative.ImPlot_ShowDemoWindow(p_open);
        }
        public static void ShowDemoWindow(ref bool p_open)
        {
            byte native_p_open_val = p_open ? (byte)1 : (byte)0;
            byte* native_p_open = &native_p_open_val;
            ImPlotNative.ImPlot_ShowDemoWindow(native_p_open);
            p_open = native_p_open_val != 0;
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool ShowInputMapSelector(ReadOnlySpan<char> label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte ret = ImPlotNative.ImPlot_ShowInputMapSelector(native_label);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
#endif
        public static bool ShowInputMapSelector(string label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte ret = ImPlotNative.ImPlot_ShowInputMapSelector(native_label);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
        public static void ShowMetricsWindow()
        {
            byte* p_popen = null;
            ImPlotNative.ImPlot_ShowMetricsWindow(p_popen);
        }
        public static void ShowMetricsWindow(ref bool p_popen)
        {
            byte native_p_popen_val = p_popen ? (byte)1 : (byte)0;
            byte* native_p_popen = &native_p_popen_val;
            ImPlotNative.ImPlot_ShowMetricsWindow(native_p_popen);
            p_popen = native_p_popen_val != 0;
        }
        public static void ShowStyleEditor()
        {
            ImPlotStyle* @ref = null;
            ImPlotNative.ImPlot_ShowStyleEditor(@ref);
        }
        public static void ShowStyleEditor(ImPlotStylePtr @ref)
        {
            ImPlotStyle* native_ref = @ref.NativePtr;
            ImPlotNative.ImPlot_ShowStyleEditor(native_ref);
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static bool ShowStyleSelector(ReadOnlySpan<char> label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte ret = ImPlotNative.ImPlot_ShowStyleSelector(native_label);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
#endif
        public static bool ShowStyleSelector(string label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte ret = ImPlotNative.ImPlot_ShowStyleSelector(native_label);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
        public static void ShowUserGuide()
        {
            ImPlotNative.ImPlot_ShowUserGuide();
        }
        public static void StyleColorsAuto()
        {
            ImPlotStyle* dst = null;
            ImPlotNative.ImPlot_StyleColorsAuto(dst);
        }
        public static void StyleColorsAuto(ImPlotStylePtr dst)
        {
            ImPlotStyle* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_StyleColorsAuto(native_dst);
        }
        public static void StyleColorsClassic()
        {
            ImPlotStyle* dst = null;
            ImPlotNative.ImPlot_StyleColorsClassic(dst);
        }
        public static void StyleColorsClassic(ImPlotStylePtr dst)
        {
            ImPlotStyle* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_StyleColorsClassic(native_dst);
        }
        public static void StyleColorsDark()
        {
            ImPlotStyle* dst = null;
            ImPlotNative.ImPlot_StyleColorsDark(dst);
        }
        public static void StyleColorsDark(ImPlotStylePtr dst)
        {
            ImPlotStyle* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_StyleColorsDark(native_dst);
        }
        public static void StyleColorsLight()
        {
            ImPlotStyle* dst = null;
            ImPlotNative.ImPlot_StyleColorsLight(dst);
        }
        public static void StyleColorsLight(ImPlotStylePtr dst)
        {
            ImPlotStyle* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_StyleColorsLight(native_dst);
        }
        public static void TagX(double x, Vector4 col)
        {
            byte round = 0;
            ImPlotNative.ImPlot_TagX_Bool(x, col, round);
        }
        public static void TagX(double x, Vector4 col, bool round)
        {
            byte native_round = round ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_TagX_Bool(x, col, native_round);
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void TagX(double x, Vector4 col, ReadOnlySpan<char> fmt)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_TagX_Str(x, col, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
#endif
        public static void TagX(double x, Vector4 col, string fmt)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_TagX_Str(x, col, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static void TagY(double y, Vector4 col)
        {
            byte round = 0;
            ImPlotNative.ImPlot_TagY_Bool(y, col, round);
        }
        public static void TagY(double y, Vector4 col, bool round)
        {
            byte native_round = round ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_TagY_Bool(y, col, native_round);
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        public static void TagY(double y, Vector4 col, ReadOnlySpan<char> fmt)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_TagY_Str(y, col, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
#endif
        public static void TagY(double y, Vector4 col, string fmt)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_TagY_Str(y, col, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
    }
}
